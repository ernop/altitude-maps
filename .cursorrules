# Altitude Maps - Cursor Rules

**ABSOLUTE RULE: NEVER use emojis in documentation files, code comments, print statements, or any text content.**
**ABSOLUTE RULE: NEVER use phrases like "code smell", "bloat" etc.
1. **NO EMOJIS IN RESPONSES**: Never use emojis when responding to the user. Keep all communication plain text.
2. **NO COMPLIMENTS OR PRAISE**: Never compliment the user or their ideas:
   - NO: "Great idea!", "Brilliant question!"
3. **NO REFLEXIVE AGREEMENT**: Don't start responses with "You're right" or "Absolutely" without first analyzing the claim. Check code/data before agreeing.

This rule applies to ALL files: .md, .py, .js, .html, .css, .txt, and any other text-based files.


## Project Context
This is a landscape visualization project focused on showing altitude of various regions across the globe.


- **Project is GLOBAL**: Supports 50 US states + 8 countries + 31 custom regions (89 total configured)

## Project Organization - Documentation Structure

### Root Level - Essential Files Only
- **`.cursorrules`** - AI agent guidance and development patterns
- **`README.md`** - Public user documentation (product-focused)
- **`DEPLOY_README.md`** - Production deployment guide (exception for ops)

### Technical Documentation (`tech/` folder)
All technical documentation goes in `tech/` folder with standardized naming:
- **`USER_GUIDE.md`** - Complete usage guide (consolidated from QUICKSTART, PRODUCT_REQUIREMENTS, etc.)
- **`TECHNICAL_REFERENCE.md`** - Complete API reference, file formats, technical specs (from TECH.md)
- **`DOWNLOAD_GUIDE.md`** - Data acquisition workflows (from UNIFIED_DOWNLOADER_GUIDE.md)
- **`DEPLOYMENT_GUIDE.md`** - Production deployment instructions and server configuration
- **`CAMERA_CONTROLS.md`** - Camera system documentation (consolidated from learnings/*CAMERA*.md)
- **`DATA_PRINCIPLES.md`** - Core data handling principles and validation rules

### Historical Learnings (`learnings/` folder)
Session notes and development threads only:
- **`SESSION_YYYYMMDD_description.md`** - Session-specific notes (use standardized date format)
- **`[FEATURE]_SUMMARY.md`** - Feature-specific learnings (e.g., DEPTH_BUFFER_PRECISION_CRITICAL.md)
- **`[FEATURE]_FIX.md`** - Bug fix summaries (e.g., ASPECT_RATIO_FIX_SUMMARY.md)

### Rules for Creating Documentation
1. **File format**: All documentation MUST be `.md` (Markdown) format - NEVER create `.txt` documentation files
2. **New user-facing content**: Add to `tech/USER_GUIDE.md` (don't create new files)
3. **New technical specs**: Add to `tech/TECHNICAL_REFERENCE.md` (don't create new files)
4. **New features**: Update both README.md (brief mention) and tech/USER_GUIDE.md (detailed)
5. **Session notes**: Create `learnings/SESSION_YYYYMMDD_description.md` with standardized naming
6. **Bug fixes/learnings**: Create `learnings/[FEATURE]_FIX_SUMMARY.md` or similar
7. **Deployment/ops**: DEPLOY_README.md at root is acceptable (operational necessity)
8. **Never create**: Other root-level documentation files (no `.txt`, no extra `.md` files - keep root clean)

### Why This Structure
- **Clean root**: Easy to find the main docs
- **Logical grouping**: All technical info in one place (`tech/`)
- **Historical preservation**: Session notes preserved in `learnings/`
- **Easy maintenance**: Fewer files, less duplication, single source of truth

## Development Patterns

### Performance-First Thinking - CRITICAL

**Before implementing ANY feature, ask these questions:**

1. **Am I doing expensive work unnecessarily?**
   - Raycasting when no systems need the results
   - Updating UI elements that are hidden
   - Recalculating values that haven't changed
   - Processing data that won't be used
   - **Rule: Check if work is needed BEFORE doing it**

3. **Am I duplicating computation?**
   - Multiple event listeners doing the same raycast
   - Multiple passes over the same data
   - Recalculating instead of caching
   - **Rule: Compute once, reuse results**

4. **Can I consolidate operations?**
   - Multiple raycasts → Single raycast with multiple result consumers

**Examples of What to Catch:**

**BAD - Multiple raycasts per event:**
```javascript
// Three separate listeners, three raycasts!
element.addEventListener('mousemove', (e) => {
    updateHUD(e);  // Does raycast #1
});
element.addEventListener('mousemove', (e) => {
    checkHover(e);  // Does raycast #2
});
element.addEventListener('mousemove', (e) => {
    updateCursor(e);  // Does raycast #3
});
```

**GOOD - Single raycast, shared results:**
```javascript
element.addEventListener('mousemove', (e) => {
    const intersects = raycaster.intersectObjects(scene.children);
    updateHUD(intersects);
    checkHover(intersects);
    updateCursor(intersects);
});
```

**BAD - Doing work when nothing needs it:**
```javascript
// Always raycasts terrain, even when HUD is hidden!
function onMouseMove(e) {
    const world = raycastToWorld(e);
    updateHUD(world);  // HUD might be hidden!
}
```

**GOOD - Skip work when not needed:**
```javascript
function onMouseMove(e) {
    if (!hudVisible && !hasInteractiveElements) {
        return;  // Skip entirely
    }
    const intersects = doRaycast(e);
    if (hudVisible) updateHUD(intersects);
    // ... other systems
}
```

**When to Raise Performance Concerns:**

- **BEFORE implementing** - If something feels wasteful, question it
- **When you see duplication** - Multiple listeners, multiple loops, multiple queries
- **In event handlers** - mousemove/wheel/scroll fire 60+ times/second
- **When conditionals exist** - If a system might be disabled, check before computing

**What to Say:**

- "This will do X raycasts per mousemove - should we consolidate?"
- "The HUD might be hidden - should we skip this work?"
- "I see three listeners doing similar work - can we combine them?"
- "This rebuilds geometry on every change - can we use uniforms instead?"

**Don't implement first, ask later. Question inefficiency upfront.**

### Event Handler Patterns - Common Hot Paths

**These handlers fire 60+ times per second. Every millisecond counts.**

#### Animation Loops (requestAnimationFrame)

**Pattern: Coalesce rapid updates, apply once per frame**
```javascript
let pendingUpdate = null;

function requestTerrainUpdate(newValue) {
    pendingUpdate = newValue;  // Don't process immediately
}

function animate() {
    if (pendingUpdate !== null) {
        applyUpdate(pendingUpdate);  // Process once per frame
        pendingUpdate = null;
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
```

#### Conditional System Checks

**CRITICAL: Check visibility/state BEFORE computing**
```javascript
// BAD - Always computes, might not be used
function onMouseMove(e) {
    const world = raycastToWorld(e);  // Expensive!
    if (hudVisible) {
        updateHUD(world);  // Might be false
    }
}

// GOOD - Skip computation if not needed
function onMouseMove(e) {
    if (!hudVisible) return;  // Early exit
    const world = raycastToWorld(e);
    updateHUD(world);
}
```

### Environment
- Always use Python 3.13 virtual environment (`venv`)
- Activate with `.\venv\Scripts\Activate.ps1` in PowerShell
- Dependencies managed via `requirements.txt`
- **Setup Script**: `.\setup.ps1` automatically installs Python 3.13 via winget (if available) or requires manual installation
- **IDE Setup**: `.vscode/settings.json` configures Cursor/VS Code to use the venv Python interpreter
  - Python path: `venv/Scripts/python.exe`
  - Venv path: `venv` (folder containing virtual environment)
  - Search exclusions: `generated/**` and `.vscode/**` excluded from search results
  - Reload window after setup if IDE doesn't recognize packages

### Code Style
- Use type hints for function parameters and returns
- Keep functions focused and single-purpose
- Document complex data transformations with inline comments
- Use meaningful variable names (prefer `elevation_data` over `ed`)

### Type Safety and Enums
- **Use enums for closed sets**: When you have a fixed set of string values (types, categories, states), use `enum.Enum`
- **String enums for serialization**: Inherit from `str` for JSON compatibility: `class MyEnum(str, Enum)`
- **Centralized location**: Place project-wide enums in `src/types.py`
- **When NOT to use enums**: Open-ended values (resolutions: 10m, 30m, future 5m), dual-nature fields (string for files, int for math)
- **Alternative**: Use `typing.Literal['value1', 'value2']` for type hints without runtime overhead
- **Example**: `RegionType` enum with USA_STATE, COUNTRY, REGION values

### Region Type System (CRITICAL - ABSOLUTE ENFORCEMENT)

**CANONICAL REFERENCE**: `tech/DATA_PIPELINE.md` - Section "Region Type System"

**ABSOLUTE RULE**: ALL code handling region types MUST use the `RegionType` enum from `src/types.py`.

```python
from src.types import RegionType

class RegionType(str, Enum):
    USA_STATE = "usa_state"  # US states
    COUNTRY = "country"      # Countries
    REGION = "region"        # Islands, ranges, custom areas
```

**ENFORCEMENT CHECKLIST**:
1. ✓ Import `RegionType` enum at top of file
2. ✓ Use enum values: `RegionType.USA_STATE` (NOT strings like `'us_state'`)
3. ✓ Check all three cases exhaustively with if/elif/elif/else
4. ✓ Raise `ValueError` for unknown types (NEVER silent fallback to None/default)

**FORBIDDEN PATTERNS**:
```python
# WRONG - String literals
if region_type == 'us_state':
if region_type == 'international':  # Not even an enum value!

# WRONG - Silent fallback
else:
    boundary_name = None  # Hides bugs!
```

**CORRECT PATTERN** (mandatory):
```python
from src.types import RegionType

if region_type == RegionType.USA_STATE:
    boundary_name = f"United States of America/{state_name}"
    boundary_type = "state"
elif region_type == RegionType.COUNTRY:
    boundary_name = country_name if clip_boundary else None
    boundary_type = "country" if clip_boundary else None
elif region_type == RegionType.REGION:
    boundary_name = region_name if clip_boundary else None
    boundary_type = None
else:
    raise ValueError(f"Unknown region type: {region_type}")
```

**WHY THIS MATTERS**: The bug we just fixed (Idaho not getting state borders) happened because code used ad-hoc strings (`'us_region'` vs `'us_state'`) that never matched, causing silent fallback to no clipping. The enum system prevents this class of bugs.

---

### Resolution Determination (CRITICAL - ABSOLUTE ENFORCEMENT)

**CANONICAL REFERENCE**: `tech/DATA_PIPELINE.md` - Section "Determine Required Resolution"

**ABSOLUTE RULE**: Resolution is NEVER hardcoded by region type. It is ALWAYS dynamically determined using Nyquist sampling.

**Process** (see `src/downloaders/orchestrator.determine_min_required_resolution()`):
1. Calculate visible pixel size: `visible_m_per_pixel = geographic_span_meters / target_pixels`
2. Apply Nyquist rule: `min_resolution <= visible_m_per_pixel / 2.0`
3. Select coarsest available resolution that meets requirement

**Available Resolutions**:
- `RegionType.USA_STATE`: `[10m, 30m, 90m]` (USGS 3DEP + OpenTopography)
- `RegionType.COUNTRY`: `[30m, 90m]` (OpenTopography only)
- `RegionType.REGION`: `[30m, 90m]` (OpenTopography only)

**Example (Idaho)**:
```
--target-pixels 512:  visible=1292m/px -> requires 90m (1292/90=14x > 2x ✓)
--target-pixels 2048: visible=323m/px  -> requires 90m (323/90=3.6x > 2x ✓)
--target-pixels 4096: visible=162m/px  -> requires 30m (162/30=5.4x > 2x ✓)
--target-pixels 8192: visible=81m/px   -> requires 10m (81/10=8.1x > 2x ✓) [US only]
```

**FORBIDDEN ASSUMPTIONS**:
- ✗ "US states always use 10m" - FALSE, depends on target_pixels
- ✗ "International regions always use 30m" - FALSE, depends on target_pixels
- ✗ "Small states need high resolution" - FALSE, depends on output size, not geographic size

**WHY THIS MATTERS**: Hardcoding resolutions wastes storage (downloading unnecessary 10m data) and breaks the quality model. The system is designed to automatically select optimal resolution based on actual viewer needs.

---

### Terminology Consistency
- **One term per concept**: Never use synonyms for the same thing (e.g., not both "category" and "region_type")
- **Unify immediately**: When you notice dual terminology, refactor to single term before it spreads - IF you are sure it really is the same thing! If in doubt, check or ask

### Import Safety - CRITICAL RULE

**NEVER use defensive imports with fallbacks. Let imports fail hard.**

#### What This Means:
- **No `try/except ImportError`** for internal code (your own modules)
- **No `try/except ImportError`** for required external libraries (rasterio, numpy, shapely, etc.)
- **No conditional imports** (`if X: import A else: import B`)
- **No fallback implementations** that work around missing imports

#### Examples of BANNED patterns:
```python
# BAD - Defensive import with fallback
try:
    import rasterio
except ImportError:
    print("Install rasterio: pip install rasterio")
    sys.exit(1)

# BAD - Conditional import with alternative
try:
    from src.borders import get_border_manager
except ImportError:
    # Use alternative implementation
    from src.legacy_borders import get_border_manager

# BAD - Optional feature with import fallback
try:
    import optional_library
    HAS_FEATURE = True
except ImportError:
    HAS_FEATURE = False
```

#### CORRECT pattern:
```python
# GOOD - Just import directly, let Python handle errors
import rasterio
from rasterio.mask import mask as rasterio_mask
import numpy as np
from src.borders import get_border_manager
```

#### Why This Rule Exists:
1. **Hides real errors**: Defensive imports mask configuration and dependency issues
2. **Allows duplication**: Alternative implementations proliferate instead of fixing root cause
3. **Confuses dependencies**: Unclear what's actually required vs optional
4. **Poor error messages**: Custom error messages are worse than Python's native ImportError

#### Exception - Test Files Only:
Test files that explicitly check if imports work are OK (e.g., `test_import_works()`), but these should be in test suites, not production code.

#### If Import Fails:
1. **Check `requirements.txt`** - Is the package listed?
2. **Install dependencies** - Run `pip install -r requirements.txt`
3. **Fix the import path** - If it's an internal module, fix the path or structure
4. **Never add try/except** - Fix the root cause instead

#### After Refactoring:
Use grep to find ALL import statements of moved functions:
```bash
grep -r "from src.module import function_name" .
```
Update all imports - don't add defensive fallbacks to old paths.

### Frontend/Web Viewer
- **jQuery**: Keep it. jQuery is widely cached and makes code more readable. Avoid Select2; use native or custom dropdowns matching the region selector pattern.
- **CSS styling**: Avoid inline styles. Use rationally-named CSS classes instead. **CRITICAL**: Inline styles (`element.style.cssText` or `element.style.property`) override CSS with highest specificity - always check JS for inline styles when CSS changes don't apply.
- **File organization**: Separate HTML and JS into different files rather than mixing them.
- **Code reuse**: Don't duplicate code, but also don't force artificial reuse when use cases actually differ. Balance DRY with clarity.
- **Recent regions**: Max 12 items, most recent first. On region load, move to front of list (deduplicates automatically).

#### UI Control Organization
- **Bidirectional controls**: Split into two clear columns with user-friendly labels (e.g., "HIGHER DETAIL" vs "LOWER DETAIL")
- **Visual hierarchy**: Use color-coded headers to distinguish control groups (green = higher detail, orange = lower detail)
- **Button layout**: Vertical stacking within columns works better than horizontal wrapping
- **Quick access buttons**: Provide MAX and DEFAULT buttons for common settings (bucket size 1 and auto-calculated optimal)
- **Labels**: Use conceptual names over technical terms (e.g., "Resolution" not "Bucket Size")

### Data Handling
- Store raw data in `data/` directory (gitignored)
- Within there, store items of different types in a distinguishable way; for example, each file type should be able to be detected.
- Cache processed data to avoid re-downloading (including masked/bordered data)
- Always validate data ranges and handle missing values
- GeoTIFF data uses natural orientation (North up, East right) - no transformations needed
- Use geopandas for geographic borders and masking operations

#### Data Flow Directories
- **`data/raw/{source}/tiles/`** - Pure reusable 1×1 degree tiles (never region-specific)
- **`data/merged/{source}/`** - Region-specific merged files (intermediate output from tile merging)
- **`data/processed/{source}/`** - Clipped/reprojected files (pipeline intermediate stage)
- **`data/borders/`** - Natural Earth border data (canonical, stable, not cache)
- **`generated/regions/`** - Final JSON exports for web viewer
- **Why separate directories**: Prevents mixing reusable upstream data with region-specific intermediate files

#### Resolution Requirements (CRITICAL)
- **Universal rule**: ALL regions use Nyquist sampling rule based on visible pixel size
- **No type-based exceptions**: Region type (USA_STATE/COUNTRY/REGION) does NOT dictate quality requirements
- **Region type is for**:
  - Download routing (which API/source to use)
  - UI organization (dropdown grouping in viewer)
- **Region type is NOT for**:
  - Quality requirements (universal rules apply)
  - Resolution selection (based on actual data needs)

#### Border Resolution (CRITICAL)
- **Always use 10m resolution borders** for accurate clipping (Natural Earth 10m dataset)
- 110m borders are TOO COARSE and miss islands/coastline details (e.g., Iceland missing 4 islands!)
- Border quality comparison:
  - 10m: High detail, captures all islands and accurate coastlines (recommended)
  - 50m: Medium detail (use only if 10m is too slow)
  - 110m: Low detail, misses features (DO NOT USE for production)
- Specify with `--border-resolution 10m` flag in ensure_region.py (now the default)

#### Tile Naming Convention (Content-Based Reuse)
**Purpose**: Enable efficient tile caching and reuse across regions to minimize storage and download overhead.

**Format**: `tile_{NS}{lat:02d}_{EW}{lon:03d}_{dataset}_{resolution}.tif`

**Examples**:
- `tile_N35_W090_srtm_30m_30m.tif` (35degN, 90degW, SRTM 30m)
- `tile_S05_E120_cop30_30m.tif` (5degS, 120degE, Copernicus DEM 30m)
- `tile_N65_W020_srtm_90m_90m.tif` (65degN, 20degW, SRTM 90m)

**Implementation**:
- Uses integer degree grid from **southwest corner** (SRTM HGT convention)
- SW corner calculation: floor for positive, trunc for negative coordinates
- Format mirrors official SRTM naming: `N##W###` → `tile_N##_W###_{source}_{res}.tif`
- Stored in shared pool: `data/raw/srtm_30m/tiles/` (not per-region subdirs)

**Why This Approach**:
1. **Industry Standard**: Follows SRTM/Copernicus DEM integer-degree grid convention used by NASA, ESA, and USGS
2. **Content-Based**: Filename reflects actual data bounds, enabling natural reuse
3. **Efficient Caching**: Adjacent regions sharing tiles (e.g., Tennessee/Kentucky) share same cache files
4. **Human Readable**: Coordinates visible at a glance, easy debugging
5. **Storage Minimization**: Avoids duplicating identical data across region directories

**Alternatives Considered**:
- Hash-based naming: Less readable, no coordinate info, harder debugging
- Region-based subdirectories: Prevents reuse, wastes storage, harder maintenance
- Floating-point coordinates: Non-deterministic rounding, incompatible with grid standards

**Future Compatibility**:
- Works with any integer-degree-based dataset (SRTM, Copernicus, ASTER, NASADEM)
- Compatible with standard tile matrix sets used in WMS/TMS services
- Supports multi-resolution scenarios (30m, 90m, etc.) via `{resolution}` suffix
- Scalable to global datasets without filename collisions
- Cache invalidation handled via dataset/resolution fields (not coordinate changes)

#### File Naming Philosophy: Abstract vs Specific

**Core Principle**: Use naming schemes that match the reusability and purpose of the data. The choice between abstract bounds-based naming and region_id-based naming should reflect whether the data is reusable global data or viewer-specific exports.

**Abstract Bounds-Based Naming** (for reusable global data):
- **Use for**: Raw downloads, processed GeoTIFFs, clipped data that could be shared across regions
- **Format**: `bbox_{bounds}_{dataset}_{resolution}.tif` (e.g., `bbox_N37_W114_N42_W109_srtm_30m_30m.tif`)
- **Why**: Enables content-based reuse - multiple regions can share same raw/processed files
- **Examples**: 
  - Raw bbox downloads: `data/raw/srtm_30m/bbox_{bounds}_{dataset}_{res}.tif`
  - Processed GeoTIFFs: `data/processed/{source}/{base_part}_processed_{pixels}px_v2.tif`
  - Clipped files: `data/clipped/{source}/{base_part}_clipped_{hash}_v1.tif`

**Region-Specific Naming** (for viewer exports and filtered data):
- **Use for**: Exported JSON files for web viewer, any data already filtered/clipped to specific boundaries
- **Format**: `{region_id}_{source}_{pixels}px_v2.json` (e.g., `ohio_srtm_30m_2048px_v2.json`)
- **Why**: These are viewer-specific exports that are already clipped to specific boundaries and filtered. They're not reusable across regions - each region has its own filtered/clipped export.
- **Examples**:
  - Viewer JSON exports: `generated/regions/{region_id}_{source}_{pixels}px_v2.json`
  - Manifest references files by `region_id` → filename mapping

**Decision Tree**:
1. Is the data **reusable across multiple regions** (same bounds, same source)? → Use abstract naming
2. Is the data **already filtered/clipped to specific boundaries** and viewer-specific? → Use region_id naming
3. Is the data a **final export for a specific use case** (viewer, visualization)? → Use region_id naming

**Data Hierarchy Understanding**:
- **Raw files** (`data/raw/`): Source of truth - preserve exactly as downloaded. These enable regeneration of all downstream files. Use abstract naming for reuse potential.
- **Processed files** (`data/clipped/`, `data/processed/`): Can regenerate from raw. Use abstract naming for reuse potential.
- **Exported files** (`generated/regions/`): Final viewer exports - use region_id naming since they're viewer-specific and already filtered.

#### Core Data Principles - CRITICAL

**Principle 1: Preserve Real-World Proportions**

Our goal is to accurately represent geographic data with correct proportions. A wide state like Tennessee (8.7° wide × 1.7° tall) must appear wide, not square. A tall state like New Jersey must appear tall.

**Implementation**: When masking to administrative boundaries (states/countries), crop the output to the actual shape boundaries, not the rectangular bounding box. This removes empty space that would distort aspect ratios.

**Standard Pipeline Flow** (in `src/pipeline.py`):
1. **Download** raw elevation data (bounding box, EPSG:4326)
2. **Clip** to boundary using `rasterio_mask()` with `crop=True` and `filled=False`
3. **Reproject** ALL EPSG:4326 regions to fix latitude distortion:
   - Always reproject (no exceptions - fixes distortion at ALL latitudes)
   - Reproject to EPSG:3857 (Web Mercator) to correct longitude compression
   - **CRITICAL**: Initialize output array with nodata, pass `src_nodata` and `dst_nodata` parameters
   - Example: Kansas (38°N) has 1.28x distortion, Iceland (65°N) has 2.37x distortion
4. **Downsample** to target resolution while preserving aspect ratio
5. **Export** to JSON with bounds converted back to EPSG:4326 for viewer

**Validation**: Export process automatically validates aspect ratio against geographic reality (see `src/validation.py`). Exports fail if proportions are >30% incorrect.

**Principle 2: Treat Input Data as Uniform 2D Grid**

Elevation data from GeoTIFFs is a simple 2D array of height values at evenly-spaced grid points. **Do not reinterpret or transform this data** based on latitude/longitude when rendering:

- **Correct**: Render as uniform square grid (each pixel = one unit of space)
- **Wrong**: Apply latitude-dependent scaling or geographic projections in the viewer

**Why**: The input data already has correct proportions built in (from the masking/cropping process). Adding transformations in the viewer would apply corrections twice, creating distortion.

**In the viewer (Three.js)**:
```javascript
// CORRECT - Simple uniform grid
const geometry = new THREE.PlaneGeometry(width, height, width-1, height-1);

// WRONG - Don't add geographic transformations
const widthMeters = lonSpan * cos(lat) * 111_320;  // NO!
const geometry = new THREE.PlaneGeometry(widthMeters, heightMeters, ...);
```

**In data export**: Ensure cropping produces correct aspect ratios so viewer needs no corrections.

**When downsampling**: Always use the **same step size for both dimensions**:
```python
# CORRECT - Preserves aspect ratio
step_size = max(1, int(math.ceil(max_dim / target_pixels)))
downsampled = elevation[::step_size, ::step_size]

# WRONG - Distorts aspect ratio
step_y = height // target_height  # Different
step_x = width // target_width    # Different
downsampled = elevation[::step_y, ::step_x]  # Distorts!
```

# Altitude Maps – Cursor Rules (Project-Specific Additions)

## Region Selector Grouping (Viewer)
- The region dropdown MUST use exactly three groups, in this order:
  1) Countries (international, alphabetical)
  2) Regions (non-country areas like islands/peninsulas/ranges, alphabetical)
  3) US states (alphabetical)
- Insert a visible divider (HR-style) between each group.
- Non-selectable divider entries should not be focusable or trigger selection.

## UI Responsiveness: Slider/Drag Debounce
**See "Performance-First Thinking" section for general principles. These are specific patterns for interactive controls.**

- Debounce expensive operations during continuous input (dragging sliders, rapid changes):
  - Recreating terrain meshes, recomputing normals, or other heavy rebuilds should be debounced (≈50–120 ms).
  - Apply immediate lightweight updates for responsiveness (e.g., height value updates) and coalesce heavy work.
- On input "change/end" events, perform a single prompt final update to settle state (e.g., compute normals once, or recreate if required by mode).

### GPU-Driven Rendering Updates (Performance Best Practices)
- Prefer GPU-side updates via shader uniforms over CPU loops or geometry rebuilds for continuous controls.
- Vertical exaggeration:
  - Use a uniform ratio relative to the build-time baseline (e.g., `uExaggeration = currentInternal / baselineInternal`).
  - Keep bar bottoms anchored with local-space offset: `transformed.y = transformed.y * uExaggeration + (uExaggeration - 1.0) * 0.5`.
  - Coalesce updates with `requestAnimationFrame`; cancel older frames and apply only the latest value.
- Tile gap (bars):
  - Scale X/Z in the shader with `uTileScale = currentTileSize / baselineTileSize`.
  - Update per frame during drag; rebuild bars only when the baseline changes (bucket size or aggregation change).
- Points: apply exaggeration with a uniform; avoid per-vertex CPU updates during drags.
- Surface: defer normals recompute to input "change"; optional future improvement is shader displacement for instant drags.

### Render Modes Product Guidance
- Bars: Instanced meshes with GPU uniforms for exaggeration and tile gap; never rebuild for those sliders.
- Points: GPU uniform for Y scaling.
- Surface: CPU updates acceptable; compute normals once on settle.
- Wireframe: Not supported in product due to poor UX and build cost; if selected, map to surface.

### Implementation Patterns
- Store shader uniform references in `material.userData` for fast updates.
- Avoid verbose logging in hot paths; keep create/rebuild logs only.
- Maintain once-per-frame scheduling for all continuous sliders.

## Libraries
- Do not add fallback loaders. If a library load fails, fix the primary load path instead of conditionally swapping to alternates.


### Data Format Versioning & Cache Invalidation
--- You must clearly and explicitly state what each filetype is andhow  it works. Don't leave it disogranized.
**CRITICAL**: When changing data processing/export format:
1. **Update the format version number** in export scripts
2. **Add version validation** on data load (fail if version mismatch)
3. **Document the change** in code comments
4. **Re-export ALL cached/generated data** - don't mix old and new formats

Cached/Generated Data Locations:
- `data/.cache/` - Masked/bordered raster data (pickled)
- `generated/` - Exported JSON for web viewer
- `generated/regions/` - Per-region exported data

To invalidate all caches after format changes:
```powershell
# Delete cached data
Remove-Item -Recurse -Force data\.cache\*
Remove-Item -Recurse -Force generated\*

# Re-export from source GeoTIFFs
python ensure_region.py <region_id> --force-reprocess
```

### Visualization
- Save outputs to `output/` directory
- Create both static (matplotlib) and interactive (plotly) versions when appropriate
- Use clear, colorblind-friendly color schemes
- Add proper titles, labels, and legends
- Include data source citations in visualizations
- **Vertical Exaggeration**: Uses real-world scale where 1.0 = true Earth proportions, 2.0 = mountains twice as steep as reality. Both X/Z (horizontal) and Y (elevation) axes are in meters based on lat/lon bounds.

### 3D Rendering (Three.js)
**CRITICAL - Camera Near/Far Planes**:
- **ALWAYS** maintain reasonable near/far plane ratios (< 1,000,000:1)
- Current safe values: `near=1, far=100000` (100,000:1 ratio)
- **NEVER** use extreme values like `near=0.001, far=50000000`
- Extreme ratios cause depth buffer artifacts (distant geometry bleeds through nearby geometry)
- Symptoms: Jagged artifacts that vary with camera angle, worse at oblique views
- **See `learnings/DEPTH_BUFFER_PRECISION_CRITICAL.md` before modifying camera settings**
- Runtime validation will log errors if ratio exceeds safe limits

#### Performance Tuning
- **Default bucket size**: Auto-adjust targets ~3,900 buckets (not 10,000) for better initial performance
- **User can refine**: Provide granular controls (-10/-5/-1/+1/+5/+10) for users who want more detail
- **Performance over quality**: Start conservative (larger buckets), let users increase detail if they want
- **Rationale**: Better to load fast with decent quality than slow with perfect quality - users will adjust if needed

### Camera Controls - Custom (Default) Scheme
**Ground Plane Camera System** - The project's custom default camera controls, tested and confirmed buttery smooth. Users can switch to alternative schemes (Google Earth, Roblox Studio, Flying, Jumping, Blender, Unity Editor) via the Camera Controls dropdown, but this is the recommended default.

**Core Architecture (CRITICAL for smoothness):**
- Fixed ground plane at y=0 (the map surface)
- Focus point anchored ON the plane (where camera looks)
- All operations relative to this plane
- **camera.lookAt() called ONLY in update() loop** (once per frame, synchronized with rendering)
- **NEVER call camera.lookAt() in mouse event handlers** - this causes high-frequency jitter
- Mouse handlers only update positions; render loop handles orientation

**Control Behaviors:**

1. **Left Drag = Pan on Ground Plane**
   - Behavior: "Grab and drag" the map surface
   - Drag DOWN → map moves down, Drag UP → map moves up
   - Drag LEFT → map moves left, Drag RIGHT → map moves right
   - Implementation: Screen-space movement for smoothness (not continuous raycasting)
   - Speed: Adaptive based on distance from focus point (distance * 0.001)
   - Camera and focus point move together, maintaining view angle

2. **Shift + Left Drag = Tilt View (Pitch Adjustment)**
   - Behavior: Change viewing angle to see more/less terrain
   - Drag DOWN → tilt down (increase phi angle, see more land/horizon)
   - Drag UP → tilt up (decrease phi angle, more overhead view)
   - Implementation: Spherical coordinate adjustment around focus point
   - Angle limits: 0.1 to π/2 - 0.01 radians (prevents camera flip)
   - Tilt speed: 0.005 radians per pixel
   - Cancels smoothly if Shift released mid-drag (prevents jank)
   - Focus point stays fixed on ground plane

3. **Middle Drag = Height Adjustment (Altitude Control)**
   - Behavior: Adjust camera altitude (Y-axis only)
   - Drag DOWN → camera moves UP (increase height)
   - Drag UP → camera moves DOWN (decrease height)
   - Horizontal position (X/Z) stays fixed
   - Focus point remains locked on ground plane
   - Height limits: 5 to 50,000 units
   - Sensitivity: 2.0 units per pixel

4. **Right Drag or Alt + Left Drag = Rotate View**
   - Behavior: Rotate view around focus point
   - Horizontal drag → turn left/right (rotate around vertical axis)
   - Vertical drag → tilt up/down (adjust viewing angle)
   - Implementation: Spherical coordinate transformation around focus point
   - Rotation speed: 0.005 radians per pixel
   - Maintains constant distance from focus point
   - Same angle limits as tilt to prevent camera flipping
   - **Alternative mappings:** Alt + Left Drag provides same behavior
   - Cancels smoothly if Alt released mid-drag (prevents jank)

5. **Mouse Wheel = Zoom Toward/Away From Cursor**
   - Behavior: Zoom toward point under cursor
   - Scroll UP (negative delta) → zoom IN = camera moves toward cursor point
   - Scroll DOWN (positive delta) → zoom OUT = camera moves away from cursor point
   - Zoom factor: 10% of distance per scroll tick
   - Minimum distance: 5 meters (prevents getting too close)
   - **Bidirectional focus shift (CRITICAL for smooth zoom):**
     - Zoom IN: Focus moves toward cursor (focusShift = +0.1)
     - Zoom OUT: Focus moves away from cursor (focusShift = -0.1)
     - This ensures camera AND focus move in same direction (no conflict)
   - Cursor point stays visually stable under mouse

6. **WASD/QE/F Keys = Keyboard Movement**
   - Behavior: Pure space movement - camera moves freely without orientation constraints
   - W = move forward in view direction
   - S = move backward
   - A = strafe left
   - D = strafe right
   - Q = move down (descend)
   - E = move up (ascend)
   - All movement maintains camera orientation (no auto-tilting or ground plane snapping)
   - Can fly through terrain geometry without sticking
   - **F = Reframe view** - Reset to fixed overhead map view:
     - Position: Fixed at (0, 2500, 2.5) looking at origin
     - Height: 2,200 units (close-up view)
     - Orientation: Rotated 180 degrees (North at top of screen, although the code is confused about this; what really shows is North despite fears.)
     - **AUTOMATIC BEHAVIOR**: Reframe is applied automatically whenever:
       - Initial page load completes (first region loaded)
       - User switches to a different region via dropdown
       - This ensures consistent, well-centered view every time data loads
     - Manual trigger: Press F key anytime to recenter
   - Works simultaneously with all mouse controls
   - Speed: Base 4.0 units/frame, accelerates which is kept as long as they're moving, no limit, but slow acceleration.
- **Disabled when typing:** WASD keys don't affect camera when typing in input fields, textareas, or dropdown inputs.

7. **Touch/Trackpad Gestures**
   - **Single finger drag** = Pan (mobile touch)
   - **Two-finger drag** = Pan (trackpad/desktop)
   - **Two-finger pinch** = Zoom in/out (pinch together = zoom in, spread apart = zoom out)
   - **Simultaneous pan + zoom** = Two-finger gesture supports both at once
   - Implementation: Touch event handlers with gesture recognition
   - Prevents default touch behavior to avoid page scrolling
   - Zoom sensitivity: 1% per pixel of pinch distance change
   - All gestures maintain ground plane model (focus stays at y=0)
   - Works on mobile devices (phones/tablets) and desktop trackpads (MacBook, etc.)

**Implementation Pattern (DO NOT DEVIATE):**
```javascript
// In mouse event handlers (onMouseMove, onWheel):
// 1. Calculate new camera position
this.camera.position.copy(newPosition);

// 2. Update focus point if needed
this.focusPoint.copy(newFocusPoint);

// 3. Update controls target
this.controls.target.copy(this.focusPoint);

// 4. DO NOT call camera.lookAt() here!
// The update() loop handles this once per frame

// In update() loop (called by requestAnimationFrame):
update() {
    if (this.enabled && this.focusPoint) {
        this.camera.lookAt(this.focusPoint); // ONLY place this is called
    }
}
```

**Why This Works:**
- Single source of truth for camera orientation (no fighting between handlers)
- Synchronized with render loop (60fps, no micro-stutters)
- Predictable timing regardless of input frequency
- Standard pattern used by Three.js OrbitControls and professional systems

**What NOT To Do:**
- Don't call camera.lookAt() in mouse handlers (causes jitter)
- Don't use continuous raycasting for pan (too slow/jerky)
- Don't make focus shift unidirectional (breaks zoom out feel)
- Don't forget to cancel operations if modifier keys released mid-drag
- Don't process keyboard shortcuts when user is typing in input fields
- Don't break existing controls when adding new features (additive only)

### Testing
- Test with small data samples first before processing large datasets
- Verify coordinate systems and projections
- Check data units and conversions
- Validate output visualizations manually

### Documentation
- Update README.md for major feature additions
- Document significant learnings in `learnings/learnings_N_<topic>.md`
- Keep inline code comments focused on "why" not "what"
- Never describe your own work as "stunning", "beautiful", "incredible" - don't be a braggart
- Be humble about work you've done, not ostentatiously humble, just light and clear
- Explain things as needed without self-praise
- **Bump version before ending session** - Run `python bump_version.py` after user-facing changes

**What "learnings" actually means:**
- Learnings are about project-specific constraints, patterns, and gotchas discovered through experience
- NOT just "how to fix X" - that's procedural knowledge anyone could look up
- YES: "We need to watch for large files because geospatial data grows quickly and breaks git"
- NO: "Here's the git command to remove large files from history"
- Think: What would future you need to remember about this project's unique characteristics?

## Data Sources Strategy

### Elevation Data Priority (User Preference)

**USA - Always Use USGS 3DEP First:**
- Source: USGS 3D Elevation Program (3DEP)
- Resolution: 1-10m (far better than global sources)
- Coverage: Full USA
- Workflow: Download bounding box → Clip to state boundaries → Cache both
- Auth: May require API key (user will provide if needed)
- URL: https://elevation.nationalmap.gov/

**Global - Prefer Nation-Specific Sources:**
Priority order for any country:
1. **National agency data** (if available) - Always check first
   - Examples: Australia (Geoscience), Japan (GSI), Germany (BKG), UK (Ordnance Survey)
   - Often higher resolution and quality than global datasets
   - May require country-specific download process
2. **Global fallback sources** (if national unavailable):
   - OpenTopography SRTM (30m, 60°N to 56°S)
   - Copernicus DEM (30m/90m, global, newest 2021)
   - ASTER GDEM (30m, 83°N to 83°S)
   - ALOS World 3D (30m free, 5m paid)

### OpenTopography Rate Limit Coordination (CRITICAL)

**All download processes MUST check shared rate limit state before downloading.**

- **Shared state file**: `data/.opentopography_rate_limit.json`
- **Automatic coordination**: All downloaders check this file before requests
- **Simple backoff**: 10 minutes initial, doubles each 401 (10min → 20min → 40min...)
- **Request spacing**: 0.5s delay between OpenTopography requests
- **Multi-process safe**: Thread-safe file locking prevents race conditions

**Implementation** (already integrated in all OpenTopography downloaders):
```python
from src.downloaders.rate_limit import check_rate_limit, record_rate_limit_hit, record_successful_request

# Before download
ok, reason = check_rate_limit()
if not ok:
    return False  # Rate limited

# After 401
if response.status_code == 401:
    record_rate_limit_hit(response.status_code)
    raise OpenTopographyRateLimitError()

# After success
record_successful_request()
```

**CLI utility**: `python check_rate_limit.py` - Check status, clear limits, wait for clearance

**See**: `tech/RATE_LIMIT_COORDINATION.md` for complete documentation

### Other Data Sources
- **ERA5 Climate Reanalysis**: Comprehensive global climate data
- **WorldClim**: Bioclimatic variables at various resolutions
- **Natural Earth**: Country borders (public domain, 10m/50m/110m resolution)

### Download and Cleaning Philosophy
1. Download by bounding box or tiles (most sources provide this)
2. Clip/mask to administrative boundaries locally (automated)
3. Cache both raw (bounding box) and cleaned (clipped) versions
4. Use two-tier caching to balance flexibility and performance

### Centralized Region Configuration
- **Single source of truth**: All regions defined in `src/regions_config.py`
- **Categories**: US_STATES, COUNTRIES, REGIONS (three categories only)
- **Key principle**: Having a region configured does NOT mean data exists - check manifest/files separately
- **Utility functions**: `check_region_data_available()`, `list_available_regions()`, `is_region_configured()`
- **CRITICAL RULE**: NO scripts should store local copies of region lists. All region information must come from `src/regions_config.py` via imports. This was enforced across all download scripts to eliminate duplication and maintain consistency.

### Adding New Regions (Viewer and Pipeline)
- **Quick path (viewer-focused):**
  1. Add RegionConfig entry to appropriate category in `src/regions_config.py`:
     - `id`: lowercase with underscores (e.g., "japan")
     - `name`: Display name (e.g., "Japan")
     - `bounds`: Tuple(west, south, east, north) in degrees
     - `description`: Optional description
     - `category`: "usa_state", "country", "region", etc.
     - `clip_boundary`: True for countries/states, False for islands/custom areas
  2. Place a GeoTIFF at `data/regions/<region_id>.tif` (or `<region_id>_elevation.tif`).
  3. Generate JSON + manifest:
     - `python ensure_region.py <region_id>` (full pipeline)
     - Outputs to `generated/regions/` and updates `regions_manifest.json`.
  4. Start the viewer: `python serve_viewer.py` and select the region.

- How the viewer groups regions:
  - Countries (international) → first group; detected from manifest names not matching island/peninsula/range patterns.
  - Regions (non-country: islands/peninsulas/ranges) → second group; names containing "island|islands|peninsula|range" are auto-classified, or add id to `knownNonCountryIds` in `js/viewer-advanced.js` if needed.
  - US states → third group; ids in the hardcoded US set or prefixed with `usa_`.

- Integrated pipeline path (unified CLI):
  - Add region to `src/regions_config.py` if not already present.
  - Use: `python ensure_region.py <region_id>` to run the full `src/pipeline.py` (clip → reproject → downsample → export → manifest update).

- Validation and consistency:
  - Keep bounds realistic and tight to minimize file sizes and preserve aspect.
  - Use 10m borders when clipping to countries/states; set `clip_boundary=False` for free-form islands if no boundary source.
  - After format changes, follow cache invalidation steps under “Data Format Versioning & Cache Invalidation”.

## Common Commands
```powershell
# Setup/activate environment
.\setup.ps1

# Interactive 3D viewer (primary interface)
python serve_viewer.py  # Visit http://localhost:8001

# ONE COMMAND: Ensure a region is ready (download + process + check)
# Works for BOTH US states and international regions
python ensure_region.py ohio                    # US state: Download if needed, process if needed
python ensure_region.py iceland                 # International: Auto-downloads via OpenTopography
python ensure_region.py new_hampshire           # Multi-word: use underscores
python ensure_region.py "new hampshire"         # Multi-word: or use quotes
python ensure_region.py tennessee --force-reprocess  # Force full rebuild
python ensure_region.py california --target-pixels 4096  # High resolution
python ensure_region.py --list-regions          # List all available regions (50 US states + 8 countries + 31 regions = 89 total)

# Reprocess existing state data
python reprocess_existing_states.py --target-pixels 2048 --states ohio kentucky
python reprocess_existing_states.py --target-pixels 2048 --force  # Full rebuild all states

# Clear all caches (use after format changes)
python clear_caches.py

# Check GeoTIFF orientation
python check_geotiff_orientation.py data/your_file.tif

# Border data management
python download_borders.py                     # Pre-download borders (110m default)
python download_borders.py --resolution 10m    # High detail borders
python download_borders.py --force             # Force re-download
python border_utils.py --list                  # List all countries
python border_utils.py --list --search "united" # Search countries
python border_utils.py --info "United States of America" # Country details
python border_utils.py --bbox "-125,25,-65,50" # Find countries in region

# Production deployment
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy -DryRun  # test
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy          # deploy

# Version bumping (after significant changes)
python bump_version.py        # Patch increment (default: 1.335 -> 1.335.1)
python bump_version.py minor  # Minor increment (1.335 -> 1.336)
python bump_version.py major  # Major increment (1.335 -> 2.0)
```

## Production Deployment

### Architecture
The viewer is a **pure client-side web application** that runs entirely in the browser:
- No server-side code required
- Works with any static web server (nginx, apache, etc.)
- All paths are relative (no configuration needed)
- External dependencies from CDN (Three.js, jQuery)

### Production vs Development Files

**Production (deploy these):**
- `interactive_viewer_advanced.html` - Main 3D viewer
- `viewer.html` - Simple viewer  
- `js/` - Client-side JavaScript
- `css/` - Stylesheets
- `generated/` - Exported elevation data (JSON)
- `README.md` - Optional documentation

**Development only (DO NOT deploy):**
- `data/` - Raw GeoTIFF files (10+ GB, stays local) - DO NOT deploy
- `src/` - Python processing code - DO NOT deploy
- `*.py` - Python scripts (processing/export only) - DO NOT deploy
- `venv/` - Virtual environment - DO NOT deploy
- `tech/`, `learnings/` - Documentation - DO NOT deploy
- Cache directories, development files - DO NOT deploy

**File Size Expectations:**
- HTML/JS/CSS: ~100 KB
- Single US state: ~500 KB - 2 MB
- All US states: ~50 MB
- Raw data (not deployed): 10+ GB

### Deployment Scripts

```powershell
# PowerShell (Windows)
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy -DryRun
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy

# Bash (Linux/Mac)
./deploy.sh -h example.com -p /var/www/maps -u deploy -d  # dry run
./deploy.sh -h example.com -p /var/www/maps -u deploy      # deploy
```

Scripts use `rsync` to:
- Upload only viewer files (excludes raw data)
- Preserve directory structure
- Sync changes efficiently (only modified files after first deploy)
- Show progress

See `DEPLOY_README.md` for detailed deployment documentation.

### Version Bumping

After significant changes, increment the viewer version to bust browser caches:

```bash
python bump_version.py        # Patch: 1.335 -> 1.335.1 (bug fixes, minor tweaks)
python bump_version.py minor  # Minor: 1.335 -> 1.336 (new features, improvements)
python bump_version.py major  # Major: 1.335 -> 2.0 (breaking changes, major redesigns)
```

**What it does:**
1. Updates `VIEWER_VERSION` in `js/viewer-advanced.js`
2. Automatically syncs HTML cache busters
3. Ready to deploy

**When to bump:**
- User-facing changes (new features, bug fixes, UI changes)
- Before deployment of significant work
- After completing a development session
- NOT needed for internal refactoring or documentation updates

## Automation Goals
- Minimize manual steps
- Make data acquisition automatic and cached
- Enable one-command visualization generation
- Support parametric variations (regions, variables, time periods)

## Border Features
- **Drawing borders**: Overlay country boundaries on maps
- **Masking data**: Clip elevation to country/state boundaries
- **177 countries available** (admin_0) + **US states/provinces** (admin_1) from Natural Earth
- **Resolutions**: 10m (detailed), 50m (medium), 110m (fast) - 10m recommended for production
- **Automatic download**: Borders downloaded automatically when needed during clipping
- **Pre-download option**: Use `download_borders.py` to cache borders ahead of time
- **Automatic caching**: Borders and masked data cached in `data/.cache/borders/`
- **Interactive viewer support**: Export borders for web viewer
- **Query tools**: `border_utils.py` for listing/searching countries and states
- Use `mask_country` parameter to clip data (e.g., "United States of America")
- Use hierarchical names for states: `"United States of America/Ohio"`
- Use `draw_borders` parameter in rendering to overlay border lines
- Primary workflow: Interactive 3D viewer at localhost:8001
- **Documentation**: See `learnings/BORDERS_CURRENT.md` for complete system details

### Git and Large Files
- This project works with large geospatial data files (GeoTIFFs, HGT files, etc.)
- When adding new data directories or processing outputs, consider whether they might contain large files
- If so, add them to `.gitignore` immediately to prevent accidental commits
- Examples: new cache directories, intermediate processing outputs, downloaded tiles
- Keep an eye on new file types that might grow large over time

#### What Should Be Ignored
Always ignore these directories and file types to keep git lean:
- **`data/`** - Raw elevation data (GeoTIFFs, HGTs) - can be 10GB+
- **`generated/`** - Exported JSON for viewer (rebuilt from data as needed)
- **`rasters/`** - Intermediate raster processing files
- **`output/`** - Visualization outputs (PNGs, etc.)
- **Cache directories**: `data/.cache/`, `110m/` (pickled borders)
- **Binary formats**: `*.tif`, `*.tiff`, `*.hgt`, `*.img`, `*.pkl`, `*.zip`, `*.gz`
- **Python artifacts**: `__pycache__/`, `venv/`, `.pytest_cache/`
- **OS junk**: `.DS_Store`, `Thumbs.db`, `debug.log`

**Rationale**: Raw geospatial data is large (hundreds of MB to GB per file), and should be downloaded/reprocessed from source rather than stored in git. Only code, small manifests, and documentation belong in version control.

### UI Essentials
- **Region selector groups**: Countries → Regions → US States; include non-selectable dividers; alphabetical inside each group.
- **Text legibility**: Primary HUD/meta/status (project name, GitHub, FPS/version, logs) should be white on dark backgrounds.
- **Button styling standard**: ALL buttons must use white text (#ffffff) in both normal and hover states. On hover, change background color only, never text color. Use smooth transitions (0.2s).
- **HUD Overlay**: Elevation/slope/aspect data display in bottom-left corner.
  - Hidden by default; toggleable via "Show HUD Overlay" checkbox in Display section.
  - Draggable anywhere on screen; position persists in localStorage.
  - Minimize button (-) in top-right collapses HUD and unchecks checkbox.
  - Settings button at bottom opens config panel (units, visible fields).
  - Tabular layout prevents value jitter.
- **Controls**: Conceptual labels ("Resolution", "Vertical Exaggeration"), not technical jargon. Provide MAX/DEFAULT quick actions.
- **Responsiveness**: Debounce heavy updates (~50–120 ms). Apply lightweight visual changes immediately; settle once on input end.
- **Flat lighting**: Simple checkbox "Flat lighting (no shading)" under Color Scheme.
  - Default off; URL `flat=1` turns it on.
  - Uses unlit materials and ambient-only lighting when on.

### Rendering & Performance
- **GPU-first updates**: Use shader uniforms for continuous changes (exaggeration, tile gap). Rebuild geometry only when baselines change.
 - Flat lighting reduces shading cost; no shadow maps are used.

### Color Schemes
- Include `auto-stretch`: computes percentile bounds client-side; honors gamma.

### Removed UI
- Shading controls (sun/azimuth/altitude/contrast) and water simulation UI are not present.
- Contour lines (elevation isolines) removed completely - no UI controls, no rendering code.
- Region navigation arrows (prev/next) hidden by default.
- Render mode selector (bars/surface/points) hidden by default.
