# Altitude Maps - Cursor Rules

**ABSOLUTE RULE: NEVER use emojis in documentation files, code comments, print statements, or any text content.**

This rule applies to ALL files: .md, .py, .js, .html, .css, .txt, and any other text-based files.

### Console Output and Unicode Handling
- **AVOID output redirection** when working with Unicode/emoji content - pipelines often fail with encoding errors on Windows
- For debugging with Unicode content, use temporary files or one-off Python scripts instead of command-line redirection
- Windows console (PowerShell/CMD) has encoding limitations - handle Unicode carefully in scripts
- Prefer writing debug output to files when dealing with emojis or non-ASCII text
- Use Unicode code point notation (U+XXXX) instead of actual emoji characters in console output

## CODE REVIEW REMINDER - READ THIS FIRST

**After writing or modifying ANY code, ALWAYS do this:**

"Great, now I want you to carefully read over all of the new code you just wrote and other existing code you just modified with 'fresh eyes' looking super carefully for any obvious bugs, errors, problems, issues, confusion, etc."

Take a moment to review with fresh perspective before moving on. Catch issues early!

## VERSION BUMP REMINDER

**After significant changes (features, bug fixes, UI updates), bump the version:**

```bash
python bump_version.py        # Patch increment (bug fixes, minor tweaks)
python bump_version.py minor  # Minor increment (new features, improvements)  
python bump_version.py major  # Major increment (breaking changes, redesigns)
```

This updates viewer version and cache busters. See "Version Bumping" section for details.

---

## Project Context
This is a landscape visualization project focused on showing altitude of various regions across the globe.


- **Project is GLOBAL**: Supports 50 US states + 70+ international regions (countries)

## Project Organization - Documentation Structure

### Root Level - Essential Files Only
- **`.cursorrules`** - AI agent guidance and development patterns
- **`README.md`** - Public user documentation (product-focused)
- **`DEPLOY_README.md`** - Production deployment guide (exception for ops)

### Technical Documentation (`tech/` folder)
All technical documentation goes in `tech/` folder with standardized naming:
- **`USER_GUIDE.md`** - Complete usage guide (consolidated from QUICKSTART, PRODUCT_REQUIREMENTS, etc.)
- **`TECHNICAL_REFERENCE.md`** - Complete API reference, file formats, technical specs (from TECH.md)
- **`DOWNLOAD_GUIDE.md`** - Data acquisition workflows (from UNIFIED_DOWNLOADER_GUIDE.md)
- **`DEPLOYMENT_GUIDE.md`** - Production deployment instructions and server configuration
- **`CAMERA_CONTROLS.md`** - Camera system documentation (consolidated from learnings/*CAMERA*.md)
- **`DATA_PRINCIPLES.md`** - Core data handling principles and validation rules

### Historical Learnings (`learnings/` folder)
Session notes and development threads only:
- **`SESSION_YYYYMMDD_description.md`** - Session-specific notes (use standardized date format)
- **`[FEATURE]_SUMMARY.md`** - Feature-specific learnings (e.g., DEPTH_BUFFER_PRECISION_CRITICAL.md)
- **`[FEATURE]_FIX.md`** - Bug fix summaries (e.g., ASPECT_RATIO_FIX_SUMMARY.md)

### Rules for Creating Documentation
1. **File format**: All documentation MUST be `.md` (Markdown) format - NEVER create `.txt` documentation files
2. **New user-facing content**: Add to `tech/USER_GUIDE.md` (don't create new files)
3. **New technical specs**: Add to `tech/TECHNICAL_REFERENCE.md` (don't create new files)
4. **New features**: Update both README.md (brief mention) and tech/USER_GUIDE.md (detailed)
5. **Session notes**: Create `learnings/SESSION_YYYYMMDD_description.md` with standardized naming
6. **Bug fixes/learnings**: Create `learnings/[FEATURE]_FIX_SUMMARY.md` or similar
7. **Deployment/ops**: DEPLOY_README.md at root is acceptable (operational necessity)
8. **Never create**: Other root-level documentation files (no `.txt`, no extra `.md` files - keep root clean)

### Why This Structure
- **Clean root**: Easy to find the main docs
- **Logical grouping**: All technical info in one place (`tech/`)
- **Historical preservation**: Session notes preserved in `learnings/`
- **Easy maintenance**: Fewer files, less duplication, single source of truth

## Development Patterns

### Environment
- Always use Python 3.13 virtual environment (`venv`)
- Activate with `.\venv\Scripts\Activate.ps1` in PowerShell
- Dependencies managed via `requirements.txt`
- **Setup Script**: `.\setup.ps1` automatically installs Python 3.13 via winget (if available) or requires manual installation
- **IDE Setup**: `.vscode/settings.json` configures Cursor/VS Code to use the venv Python interpreter
  - Python path: `venv/Scripts/python.exe`
  - Venv path: `venv` (folder containing virtual environment)
  - Search exclusions: `generated/**` and `.vscode/**` excluded from search results
  - Reload window after setup if IDE doesn't recognize packages

### Code Style
- Use type hints for function parameters and returns
- Keep functions focused and single-purpose
- Document complex data transformations with inline comments
- Use meaningful variable names (prefer `elevation_data` over `ed`)

### Frontend/Web Viewer
- **jQuery**: Keep it. jQuery is widely cached and makes code more readable. Avoid Select2; use native or custom dropdowns matching the region selector pattern.
- **CSS styling**: Avoid inline styles. Use rationally-named CSS classes instead.
- **File organization**: Separate HTML and JS into different files rather than mixing them.
- **Code reuse**: Don't duplicate code, but also don't force artificial reuse when use cases actually differ. Balance DRY with clarity.

#### UI Control Organization
- **Bidirectional controls**: Split into two clear columns with user-friendly labels (e.g., "HIGHER DETAIL" vs "LOWER DETAIL")
- **Visual hierarchy**: Use color-coded headers to distinguish control groups (green = higher detail, orange = lower detail)
- **Button layout**: Vertical stacking within columns works better than horizontal wrapping
- **Quick access buttons**: Provide MAX and DEFAULT buttons for common settings (bucket size 1 and auto-calculated optimal)
- **Labels**: Use conceptual names over technical terms (e.g., "Resolution" not "Bucket Size")

### Data Handling
- Store raw data in `data/` directory (gitignored)
- Within there, store items of different types in a distinguishable way; for example, each file type should be able to be detected.
- Cache processed data to avoid re-downloading (including masked/bordered data)
- Always validate data ranges and handle missing values
- GeoTIFF data uses natural orientation (North up, East right) - no transformations needed
- Use geopandas for geographic borders and masking operations

#### Border Resolution (CRITICAL)
- **Always use 10m resolution borders** for accurate clipping (Natural Earth 10m dataset)
- 110m borders are TOO COARSE and miss islands/coastline details (e.g., Iceland missing 4 islands!)
- Border quality comparison:
  - 10m: High detail, captures all islands and accurate coastlines (recommended)
  - 50m: Medium detail (use only if 10m is too slow)
  - 110m: Low detail, misses features (DO NOT USE for production)
- Specify with `--border-resolution 10m` flag in ensure_region.py (now the default)

#### Tile Naming Convention (Content-Based Reuse)
**Purpose**: Enable efficient tile caching and reuse across regions to minimize storage and download overhead.

**Format**: `tile_{NS}{lat:02d}_{EW}{lon:03d}_{dataset}_{resolution}.tif`

**Examples**:
- `tile_N35_W090_srtm_30m_30m.tif` (35degN, 90degW, SRTM 30m)
- `tile_S05_E120_cop30_30m.tif` (5degS, 120degE, Copernicus DEM 30m)
- `tile_N65_W020_srtm_90m_90m.tif` (65degN, 20degW, SRTM 90m)

**Implementation**:
- Uses integer degree grid from **southwest corner** (SRTM HGT convention)
- SW corner calculation: floor for positive, trunc for negative coordinates
- Format mirrors official SRTM naming: `N##W###` → `tile_N##_W###_{source}_{res}.tif`
- Stored in shared pool: `data/raw/srtm_30m/tiles/` (not per-region subdirs)

**Why This Approach**:
1. **Industry Standard**: Follows SRTM/Copernicus DEM integer-degree grid convention used by NASA, ESA, and USGS
2. **Content-Based**: Filename reflects actual data bounds, enabling natural reuse
3. **Efficient Caching**: Adjacent regions sharing tiles (e.g., Tennessee/Kentucky) share same cache files
4. **Human Readable**: Coordinates visible at a glance, easy debugging
5. **Storage Minimization**: Avoids duplicating identical data across region directories

**Alternatives Considered**:
- Hash-based naming: Less readable, no coordinate info, harder debugging
- Region-based subdirectories: Prevents reuse, wastes storage, harder maintenance
- Floating-point coordinates: Non-deterministic rounding, incompatible with grid standards

**Future Compatibility**:
- Works with any integer-degree-based dataset (SRTM, Copernicus, ASTER, NASADEM)
- Compatible with standard tile matrix sets used in WMS/TMS services
- Supports multi-resolution scenarios (30m, 90m, etc.) via `{resolution}` suffix
- Scalable to global datasets without filename collisions
- Cache invalidation handled via dataset/resolution fields (not coordinate changes)

#### Core Data Principles - CRITICAL

**Principle 1: Preserve Real-World Proportions**

Our goal is to accurately represent geographic data with correct proportions. A wide state like Tennessee (8.7° wide × 1.7° tall) must appear wide, not square. A tall state like New Jersey must appear tall.

**Implementation**: When masking to administrative boundaries (states/countries), crop the output to the actual shape boundaries, not the rectangular bounding box. This removes empty space that would distort aspect ratios.

**Standard Pipeline Flow** (in `src/pipeline.py`):
1. **Download** raw elevation data (bounding box, EPSG:4326)
2. **Clip** to boundary using `rasterio_mask()` with `crop=True` and `filled=False`
3. **Reproject** ALL EPSG:4326 regions to fix latitude distortion:
   - Always reproject (no exceptions - fixes distortion at ALL latitudes)
   - Reproject to EPSG:3857 (Web Mercator) to correct longitude compression
   - **CRITICAL**: Initialize output array with nodata, pass `src_nodata` and `dst_nodata` parameters
   - Example: Kansas (38°N) has 1.28x distortion, Iceland (65°N) has 2.37x distortion
4. **Downsample** to target resolution while preserving aspect ratio
5. **Export** to JSON with bounds converted back to EPSG:4326 for viewer

**Validation**: Export process automatically validates aspect ratio against geographic reality (see `src/validation.py`). Exports fail if proportions are >30% incorrect.

**Principle 2: Treat Input Data as Uniform 2D Grid**

Elevation data from GeoTIFFs is a simple 2D array of height values at evenly-spaced grid points. **Do not reinterpret or transform this data** based on latitude/longitude when rendering:

- **Correct**: Render as uniform square grid (each pixel = one unit of space)
- **Wrong**: Apply latitude-dependent scaling or geographic projections in the viewer

**Why**: The input data already has correct proportions built in (from the masking/cropping process). Adding transformations in the viewer would apply corrections twice, creating distortion.

**In the viewer (Three.js)**:
```javascript
// CORRECT - Simple uniform grid
const geometry = new THREE.PlaneGeometry(width, height, width-1, height-1);

// WRONG - Don't add geographic transformations
const widthMeters = lonSpan * cos(lat) * 111_320;  // NO!
const geometry = new THREE.PlaneGeometry(widthMeters, heightMeters, ...);
```

**In data export**: Ensure cropping produces correct aspect ratios so viewer needs no corrections.

**When downsampling**: Always use the **same step size for both dimensions**:
```python
# CORRECT - Preserves aspect ratio
step_size = max(1, int(math.ceil(max_dim / target_pixels)))
downsampled = elevation[::step_size, ::step_size]

# WRONG - Distorts aspect ratio
step_y = height // target_height  # Different
step_x = width // target_width    # Different
downsampled = elevation[::step_y, ::step_x]  # Distorts!
```

# Altitude Maps – Cursor Rules (Project-Specific Additions)

## Region Selector Grouping (Viewer)
- The region dropdown MUST use exactly three groups, in this order:
  1) Countries (international, alphabetical)
  2) Regions (non-country areas like islands/peninsulas/ranges, alphabetical)
  3) US states (alphabetical)
- Insert a visible divider (HR-style) between each group.
- Non-selectable divider entries should not be focusable or trigger selection.

## UI Responsiveness: Slider/Drag Debounce
- Debounce expensive operations during continuous input (dragging sliders, rapid changes):
  - Recreating terrain meshes, recomputing normals, or other heavy rebuilds should be debounced (≈50–120 ms).
  - Apply immediate lightweight updates for responsiveness (e.g., height value updates) and coalesce heavy work.
- On input "change/end" events, perform a single prompt final update to settle state (e.g., compute normals once, or recreate if required by mode).

### GPU-Driven Rendering Updates (Performance Best Practices)
- Prefer GPU-side updates via shader uniforms over CPU loops or geometry rebuilds for continuous controls.
- Vertical exaggeration:
  - Use a uniform ratio relative to the build-time baseline (e.g., `uExaggeration = currentInternal / baselineInternal`).
  - Keep bar bottoms anchored with local-space offset: `transformed.y = transformed.y * uExaggeration + (uExaggeration - 1.0) * 0.5`.
  - Coalesce updates with `requestAnimationFrame`; cancel older frames and apply only the latest value.
- Tile gap (bars):
  - Scale X/Z in the shader with `uTileScale = currentTileSize / baselineTileSize`.
  - Update per frame during drag; rebuild bars only when the baseline changes (bucket size or aggregation change).
- Points: apply exaggeration with a uniform; avoid per-vertex CPU updates during drags.
- Surface: defer normals recompute to input "change"; optional future improvement is shader displacement for instant drags.

### Render Modes Product Guidance
- Bars: Instanced meshes with GPU uniforms for exaggeration and tile gap; never rebuild for those sliders.
- Points: GPU uniform for Y scaling.
- Surface: CPU updates acceptable; compute normals once on settle.
- Wireframe: Not supported in product due to poor UX and build cost; if selected, map to surface.

### Implementation Patterns
- Store shader uniform references in `material.userData` for fast updates.
- Avoid verbose logging in hot paths; keep create/rebuild logs only.
- Maintain once-per-frame scheduling for all continuous sliders.

## Libraries
- Do not add fallback loaders. If a library load fails, fix the primary load path instead of conditionally swapping to alternates.


### Data Format Versioning & Cache Invalidation
--- You must clearly and explicitly state what each filetype is andhow  it works. Don't leave it disogranized.
**CRITICAL**: When changing data processing/export format:
1. **Update the format version number** in export scripts
2. **Add version validation** on data load (fail if version mismatch)
3. **Document the change** in code comments
4. **Re-export ALL cached/generated data** - don't mix old and new formats

Cached/Generated Data Locations:
- `data/.cache/` - Masked/bordered raster data (pickled)
- `generated/` - Exported JSON for web viewer
- `generated/regions/` - Per-region exported data

To invalidate all caches after format changes:
```powershell
# Delete cached data
Remove-Item -Recurse -Force data\.cache\*
Remove-Item -Recurse -Force generated\*

# Re-export from source GeoTIFFs
python export_for_web_viewer.py
python download_regions.py  # If using regions
```

### Visualization
- Save outputs to `output/` directory
- Create both static (matplotlib) and interactive (plotly) versions when appropriate
- Use clear, colorblind-friendly color schemes
- Add proper titles, labels, and legends
- Include data source citations in visualizations
- **Vertical Exaggeration**: Uses real-world scale where 1.0 = true Earth proportions, 2.0 = mountains twice as steep as reality. Both X/Z (horizontal) and Y (elevation) axes are in meters based on lat/lon bounds.

### 3D Rendering (Three.js)
**CRITICAL - Camera Near/Far Planes**:
- **ALWAYS** maintain reasonable near/far plane ratios (< 1,000,000:1)
- Current safe values: `near=1, far=100000` (100,000:1 ratio)
- **NEVER** use extreme values like `near=0.001, far=50000000`
- Extreme ratios cause depth buffer artifacts (distant geometry bleeds through nearby geometry)
- Symptoms: Jagged artifacts that vary with camera angle, worse at oblique views
- **See `learnings/DEPTH_BUFFER_PRECISION_CRITICAL.md` before modifying camera settings**
- Runtime validation will log errors if ratio exceeds safe limits

#### Performance Tuning
- **Default bucket size**: Auto-adjust targets ~3,900 buckets (not 10,000) for better initial performance
- **User can refine**: Provide granular controls (-10/-5/-1/+1/+5/+10) for users who want more detail
- **Performance over quality**: Start conservative (larger buckets), let users increase detail if they want
- **Rationale**: Better to load fast with decent quality than slow with perfect quality - users will adjust if needed

### Camera Controls - Best Known Scheme (Oct 2025)
**Ground Plane Camera System** - Tested and confirmed buttery smooth, modeled after Google Maps/Earth.


**Core Architecture (CRITICAL for smoothness):**
- Fixed ground plane at y=0 (the map surface)
- Focus point anchored ON the plane (where camera looks)
- All operations relative to this plane
- **camera.lookAt() called ONLY in update() loop** (once per frame, synchronized with rendering)
- **NEVER call camera.lookAt() in mouse event handlers** - this causes high-frequency jitter
- Mouse handlers only update positions; render loop handles orientation

**Control Behaviors:**

1. **Left Drag = Pan on Ground Plane**
   - Behavior: "Grab and drag" the map surface
   - Drag DOWN → map moves down, Drag UP → map moves up
   - Drag LEFT → map moves left, Drag RIGHT → map moves right
   - Implementation: Screen-space movement for smoothness (not continuous raycasting)
   - Speed: Adaptive based on distance from focus point (distance * 0.001)
   - Camera and focus point move together, maintaining view angle

2. **Shift + Left Drag = Tilt View (Pitch Adjustment)**
   - Behavior: Change viewing angle to see more/less terrain
   - Drag DOWN → tilt down (increase phi angle, see more land/horizon)
   - Drag UP → tilt up (decrease phi angle, more overhead view)
   - Implementation: Spherical coordinate adjustment around focus point
   - Angle limits: 0.1 to π/2 - 0.01 radians (prevents camera flip)
   - Tilt speed: 0.005 radians per pixel
   - Cancels smoothly if Shift released mid-drag (prevents jank)
   - Focus point stays fixed on ground plane

3. **Right Drag = Rotate View (Google Earth style)**
   - Behavior: Rotate view around focus point (Google Earth style)
   - Horizontal drag → turn left/right (rotate around vertical axis)
   - Vertical drag → tilt up/down (adjust viewing angle)
   - Implementation: Spherical coordinate transformation around focus point
   - Rotation speed: 0.005 radians per pixel
   - Maintains constant distance from focus point
   - Same angle limits as tilt to prevent camera flipping
   - **Alternative mapping:** Alt + Left Drag (Maya/3ds Max/Cinema 4D style - same behavior)
   - Cancels smoothly if Alt released mid-drag (prevents jank)

4. **Mouse Wheel = Zoom Toward/Away From Cursor**
   - Behavior: Zoom toward point under cursor (Google Maps style)
   - Scroll UP (negative delta) → zoom IN = camera moves toward cursor point
   - Scroll DOWN (positive delta) → zoom OUT = camera moves away from cursor point
   - Zoom factor: 10% of distance per scroll tick
   - Minimum distance: 5 meters (prevents getting too close)
   - **Bidirectional focus shift (CRITICAL for smooth zoom):**
     - Zoom IN: Focus moves toward cursor (focusShift = +0.1)
     - Zoom OUT: Focus moves away from cursor (focusShift = -0.1)
     - This ensures camera AND focus move in same direction (no conflict)
   - Cursor point stays visually stable under mouse

5. **WASD/QE/F Keys = Keyboard Movement**
   - Behavior: First-person style camera movement (always active when not typing)
   - W = move forward in view direction
   - S = move backward
   - A = strafe left
   - D = strafe right
   - Q = move down (descend)
   - E = move up (ascend)
   - **F = Reframe view** - Reset to fixed overhead map view:
     - Position: Fixed at (0, 2500, 2.5) looking at origin
     - Height: 2,200 units (close-up view)
     - Orientation: Rotated 180 degrees (North at top of screen, although the code is confused about this; what really shows is North despite fears.)
     - **AUTOMATIC BEHAVIOR**: Reframe is applied automatically whenever:
       - Initial page load completes (first region loaded)
       - User switches to a different region via dropdown
       - This ensures consistent, well-centered view every time data loads
     - Manual trigger: Press F key anytime to recenter
     - Perfect for getting oriented after exploring
   - Works simultaneously with all mouse controls
   - Speed: 2.0 units per frame
   - Focus point moves with camera to maintain ground plane model
- **Disabled when typing:** WASD keys don't affect camera when typing in input fields, textareas, or dropdown inputs.

6. **Touch/Trackpad Gestures** (NEW - Google Maps style)
   - **Single finger drag** = Pan (mobile touch)
   - **Two-finger drag** = Pan (trackpad/desktop, Google Maps style)
   - **Two-finger pinch** = Zoom in/out (pinch together = zoom in, spread apart = zoom out)
   - **Simultaneous pan + zoom** = Two-finger gesture supports both at once
   - Implementation: Touch event handlers with gesture recognition
   - Prevents default touch behavior to avoid page scrolling
   - Zoom sensitivity: 1% per pixel of pinch distance change
   - All gestures maintain ground plane model (focus stays at y=0)
   - Works on mobile devices (phones/tablets) and desktop trackpads (MacBook, etc.)

**Implementation Pattern (DO NOT DEVIATE):**
```javascript
// In mouse event handlers (onMouseMove, onWheel):
// 1. Calculate new camera position
this.camera.position.copy(newPosition);

// 2. Update focus point if needed
this.focusPoint.copy(newFocusPoint);

// 3. Update controls target
this.controls.target.copy(this.focusPoint);

// 4. DO NOT call camera.lookAt() here!
// The update() loop handles this once per frame

// In update() loop (called by requestAnimationFrame):
update() {
    if (this.enabled && this.focusPoint) {
        this.camera.lookAt(this.focusPoint); // ONLY place this is called
    }
}
```

**Why This Works:**
- Single source of truth for camera orientation (no fighting between handlers)
- Synchronized with render loop (60fps, no micro-stutters)
- Predictable timing regardless of input frequency
- Standard pattern used by Three.js OrbitControls and professional systems

**What NOT To Do:**
- Don't call camera.lookAt() in mouse handlers (causes jitter)
- Don't use continuous raycasting for pan (too slow/jerky)
- Don't make focus shift unidirectional (breaks zoom out feel)
- Don't forget to cancel operations if modifier keys released mid-drag
- Don't process keyboard shortcuts when user is typing in input fields
- Don't break existing controls when adding new features (additive only)

### Testing
- Test with small data samples first before processing large datasets
- Verify coordinate systems and projections
- Check data units and conversions
- Validate output visualizations manually

### Documentation
- Update README.md for major feature additions
- Document significant learnings in `learnings/learnings_N_<topic>.md`
- Keep inline code comments focused on "why" not "what"
- Never describe your own work as "stunning", "beautiful", "incredible" - don't be a braggart
- Be humble about work you've done, not ostentatiously humble, just light and clear
- Explain things as needed without self-praise
- **Bump version before ending session** - Run `python bump_version.py` after user-facing changes

**What "learnings" actually means:**
- Learnings are about project-specific constraints, patterns, and gotchas discovered through experience
- NOT just "how to fix X" - that's procedural knowledge anyone could look up
- YES: "We need to watch for large files because geospatial data grows quickly and breaks git"
- NO: "Here's the git command to remove large files from history"
- Think: What would future you need to remember about this project's unique characteristics?

## Data Sources Strategy

### Elevation Data Priority (User Preference)

**USA - Always Use USGS 3DEP First:**
- Source: USGS 3D Elevation Program (3DEP)
- Resolution: 1-10m (far better than global sources)
- Coverage: Full USA
- Workflow: Download bounding box → Clip to state boundaries → Cache both
- Auth: May require API key (user will provide if needed)
- URL: https://elevation.nationalmap.gov/

**Global - Prefer Nation-Specific Sources:**
Priority order for any country:
1. **National agency data** (if available) - Always check first
   - Examples: Australia (Geoscience), Japan (GSI), Germany (BKG), UK (Ordnance Survey)
   - Often higher resolution and quality than global datasets
   - May require country-specific download process
2. **Global fallback sources** (if national unavailable):
   - OpenTopography SRTM (30m, 60°N to 56°S)
   - Copernicus DEM (30m/90m, global, newest 2021)
   - ASTER GDEM (30m, 83°N to 83°S)
   - ALOS World 3D (30m free, 5m paid)

### Other Data Sources
- **ERA5 Climate Reanalysis**: Comprehensive global climate data
- **WorldClim**: Bioclimatic variables at various resolutions
- **Natural Earth**: Country borders (public domain, 10m/50m/110m resolution)

### Download and Cleaning Philosophy
1. Download by bounding box or tiles (most sources provide this)
2. Clip/mask to administrative boundaries locally (automated)
3. Cache both raw (bounding box) and cleaned (clipped) versions
4. Use two-tier caching to balance flexibility and performance

### Centralized Region Configuration
- **Single source of truth**: All regions defined in `src/regions_config.py`
- **Categories**: US_STATES, COUNTRIES, REGIONS (three categories only)
- **Key principle**: Having a region configured does NOT mean data exists - check manifest/files separately
- **Utility functions**: `check_region_data_available()`, `list_available_regions()`, `is_region_configured()`
- **CRITICAL RULE**: NO scripts should store local copies of region lists. All region information must come from `src/regions_config.py` via imports. This was enforced across all download scripts to eliminate duplication and maintain consistency.

### Adding New Regions (Viewer and Pipeline)
- **Quick path (viewer-focused):**
  1. Add RegionConfig entry to appropriate category in `src/regions_config.py`:
     - `id`: lowercase with underscores (e.g., "japan")
     - `name`: Display name (e.g., "Japan")
     - `bounds`: Tuple(west, south, east, north) in degrees
     - `description`: Optional description
     - `category`: "usa_state", "country", "region", etc.
     - `clip_boundary`: True for countries/states, False for islands/custom areas
  2. Place a GeoTIFF at `data/regions/<region_id>.tif` (or `<region_id>_elevation.tif`).
  3. Generate JSON + manifest:
     - `python ensure_region.py <region_id>` (full pipeline) or
     - `python download_regions.py --regions <region_id>` (legacy)
     - Outputs to `generated/regions/` and updates `regions_manifest.json`.
  4. Start the viewer: `python serve_viewer.py` and select the region.

- How the viewer groups regions:
  - Countries (international) → first group; detected from manifest names not matching island/peninsula/range patterns.
  - Regions (non-country: islands/peninsulas/ranges) → second group; names containing “island|islands|peninsula|range” are auto-classified, or add id to `knownNonCountryIds` in `js/viewer-advanced.js` if needed.
  - US states → third group; ids in the hardcoded US set or prefixed with `usa_`.

- Integrated pipeline path (unified CLI):
  - Add or rely on entries aggregated by `src/regions_registry.py` (pulls from source-specific modules and `download_regions.py`).
  - Then use: `python ensure_region.py <region_id>` to run the full `src/pipeline.py` (clip → reproject → downsample → export → manifest update).

- Validation and consistency:
  - Keep bounds realistic and tight to minimize file sizes and preserve aspect.
  - Use 10m borders when clipping to countries/states; set `clip_boundary=False` for free-form islands if no boundary source.
  - After format changes, follow cache invalidation steps under “Data Format Versioning & Cache Invalidation”.

## Common Commands
```powershell
# Setup/activate environment
.\setup.ps1

# Interactive 3D viewer (primary interface)
python serve_viewer.py  # Visit http://localhost:8001

# ONE COMMAND: Ensure a region is ready (download + process + check)
# Works for BOTH US states and international regions
python ensure_region.py ohio                    # US state: Download if needed, process if needed
python ensure_region.py iceland                 # International: Auto-downloads via OpenTopography
python ensure_region.py new_hampshire           # Multi-word: use underscores
python ensure_region.py "new hampshire"         # Multi-word: or use quotes
python ensure_region.py tennessee --force-reprocess  # Force full rebuild
python ensure_region.py california --target-pixels 4096  # High resolution
python ensure_region.py --list-regions          # List all available regions (50 states + 70+ countries)

# Check region data through entire pipeline
python check_region.py ohio                     # Check all stages (raw → JSON)
python check_region.py north_dakota --verbose   # Multi-word state (detailed output)
python check_region.py tennessee --raw-only     # Only check raw file

# Reprocess existing state data
python reprocess_existing_states.py --target-pixels 2048 --states ohio kentucky
python reprocess_existing_states.py --target-pixels 2048 --force  # Full rebuild all states

# Export data for web viewer
python export_for_web_viewer.py data/usa.tif

# Clear all caches (use after format changes)
python clear_caches.py

# Check GeoTIFF orientation
python check_geotiff_orientation.py data/your_file.tif

# Run visualization (static output)
python visualize.py --region global --variable temperature

# Download regions
python download_regions.py

# Work with borders
python border_utils.py --list  # List available countries
python border_utils.py --test your_data.tif  # Test borders on data

# Production deployment
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy -DryRun  # test
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy          # deploy

# Version bumping (after significant changes)
python bump_version.py        # Patch increment (default: 1.335 -> 1.335.1)
python bump_version.py minor  # Minor increment (1.335 -> 1.336)
python bump_version.py major  # Major increment (1.335 -> 2.0)
```

## Production Deployment

### Architecture
The viewer is a **pure client-side web application** that runs entirely in the browser:
- No server-side code required
- Works with any static web server (nginx, apache, etc.)
- All paths are relative (no configuration needed)
- External dependencies from CDN (Three.js, jQuery)

### Production vs Development Files

**Production (deploy these):**
- `interactive_viewer_advanced.html` - Main 3D viewer
- `viewer.html` - Simple viewer  
- `js/` - Client-side JavaScript
- `css/` - Stylesheets
- `generated/` - Exported elevation data (JSON)
- `README.md` - Optional documentation

**Development only (DO NOT deploy):**
- `data/` - Raw GeoTIFF files (10+ GB, stays local) - DO NOT deploy
- `src/` - Python processing code - DO NOT deploy
- `*.py` - Python scripts (processing/export only) - DO NOT deploy
- `venv/` - Virtual environment - DO NOT deploy
- `tech/`, `learnings/` - Documentation - DO NOT deploy
- Cache directories, development files - DO NOT deploy

**File Size Expectations:**
- HTML/JS/CSS: ~100 KB
- Single US state: ~500 KB - 2 MB
- All US states: ~50 MB
- Raw data (not deployed): 10+ GB

### Deployment Scripts

```powershell
# PowerShell (Windows)
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy -DryRun
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy

# Bash (Linux/Mac)
./deploy.sh -h example.com -p /var/www/maps -u deploy -d  # dry run
./deploy.sh -h example.com -p /var/www/maps -u deploy      # deploy
```

Scripts use `rsync` to:
- Upload only viewer files (excludes raw data)
- Preserve directory structure
- Sync changes efficiently (only modified files after first deploy)
- Show progress

See `DEPLOY_README.md` for detailed deployment documentation.

### Version Bumping

After significant changes, increment the viewer version to bust browser caches:

```bash
python bump_version.py        # Patch: 1.335 -> 1.335.1 (bug fixes, minor tweaks)
python bump_version.py minor  # Minor: 1.335 -> 1.336 (new features, improvements)
python bump_version.py major  # Major: 1.335 -> 2.0 (breaking changes, major redesigns)
```

**What it does:**
1. Updates `VIEWER_VERSION` in `js/viewer-advanced.js`
2. Automatically syncs HTML cache busters
3. Ready to deploy

**When to bump:**
- User-facing changes (new features, bug fixes, UI changes)
- Before deployment of significant work
- After completing a development session
- NOT needed for internal refactoring or documentation updates

## Automation Goals
- Minimize manual steps
- Make data acquisition automatic and cached
- Enable one-command visualization generation
- Support parametric variations (regions, variables, time periods)

## Border Features
- **Drawing borders**: Overlay country boundaries on maps
- **Masking data**: Clip elevation to country boundaries
- **177 countries available** from Natural Earth (10m/50m/110m resolution)
- **Automatic caching** of borders and masked data
- **Interactive viewer support**: Export borders for web viewer
- Use `mask_country` parameter to clip data (e.g., "United States of America")
- Use `draw_borders` parameter in rendering to overlay border lines
- Primary workflow: Interactive 3D viewer at localhost:8001

### Git and Large Files
- This project works with large geospatial data files (GeoTIFFs, HGT files, etc.)
- When adding new data directories or processing outputs, consider whether they might contain large files
- If so, add them to `.gitignore` immediately to prevent accidental commits
- Examples: new cache directories, intermediate processing outputs, downloaded tiles
- Keep an eye on new file types that might grow large over time

#### What Should Be Ignored
Always ignore these directories and file types to keep git lean:
- **`data/`** - Raw elevation data (GeoTIFFs, HGTs) - can be 10GB+
- **`generated/`** - Exported JSON for viewer (rebuilt from data as needed)
- **`rasters/`** - Intermediate raster processing files
- **`output/`** - Visualization outputs (PNGs, etc.)
- **Cache directories**: `data/.cache/`, `110m/` (pickled borders)
- **Binary formats**: `*.tif`, `*.tiff`, `*.hgt`, `*.img`, `*.pkl`, `*.zip`, `*.gz`
- **Python artifacts**: `__pycache__/`, `venv/`, `.pytest_cache/`
- **OS junk**: `.DS_Store`, `Thumbs.db`, `debug.log`

**Rationale**: Raw geospatial data is large (hundreds of MB to GB per file), and should be downloaded/reprocessed from source rather than stored in git. Only code, small manifests, and documentation belong in version control.

### UI Essentials
- **Region selector groups**: Countries → Regions → US States; include non-selectable dividers; alphabetical inside each group.
- **Text legibility**: Primary HUD/meta/status (project name, GitHub, FPS/version, logs) should be white on dark backgrounds.
- **Controls**: Conceptual labels ("Resolution", "Vertical Exaggeration"), not technical jargon. Provide MAX/DEFAULT quick actions.
- **Responsiveness**: Debounce heavy updates (~50–120 ms). Apply lightweight visual changes immediately; settle once on input end.
- **Flat lighting**: Simple checkbox "Flat lighting (no shading)" under Color Scheme.
  - Default off; URL `flat=1` turns it on.
  - Uses unlit materials and ambient-only lighting when on.

### Rendering & Performance
- **GPU-first updates**: Use shader uniforms for continuous changes (exaggeration, tile gap). Rebuild geometry only when baselines change.
 - Flat lighting reduces shading cost; no shadow maps are used.

### Color Schemes
- Include `auto-stretch`: computes percentile bounds client-side; honors gamma.

### Removed UI
- Shading controls (sun/azimuth/altitude/contrast) and water simulation UI are not present.
