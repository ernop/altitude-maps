# Altitude Maps - Cursor Rules

**ABSOLUTE RULE: NEVER use emojis in documentation files, code comments, print statements, or any text content.**
**ABSOLUTE RULE: NEVER use phrases like "code smell", "bloat" etc.
**ABSOLUTE RULE: NEVER include API keys, passwords, tokens, or any credentials in documentation, code comments, or example files.**
1. **NO EMOJIS IN RESPONSES**: Never use emojis when responding to the user. Keep all communication plain text.
2. **NO COMPLIMENTS OR PRAISE**: Never compliment the user or their ideas:
   - NO: "Great idea!", "Brilliant question!"
3. **NO REFLEXIVE AGREEMENT**: Don't start responses with "You're right" or "Absolutely" without first analyzing the claim. Check code/data before agreeing.
4. **NO CREDENTIALS IN DOCUMENTATION**: Never include actual API keys, passwords, or tokens in documentation files, README files, or code examples:
   - Use placeholders like `YOUR_API_KEY_HERE` or `<insert-your-key>`
   - Reference configuration files without exposing their contents
   - Document where to obtain keys, not the keys themselves

This rule applies to ALL files: .md, .py, .js, .html, .css, .txt, and any other text-based files.


## Project Context
This is a landscape visualization project focused on showing altitude of various regions across the globe.


- **Project is GLOBAL**: Supports 50 US states + 8 countries + 31 custom regions (89 total configured)

## Project Organization - Documentation Structure

### Root Level - Minimal Files Only
- **`.cursorrules`** - All technical/programming guidance (this file)
- **`README.md`** - Features only, NO technical language (no pixels, code, CSS, lat/long, etc.)
- **`DEPLOY_README.md`** - Deployment guide
- **`install.md`** - Installation instructions
- **`technicalDetails.md`** - Technical specifications

**No other MD files in root.** All technical guidance goes in `.cursorrules`.

## Development Patterns

### Performance-First Thinking - CRITICAL

**Before implementing ANY feature, ask these questions:**

1. **Am I doing expensive work unnecessarily?**
   - Raycasting when no systems need the results
   - Updating UI elements that are hidden
   - Recalculating values that haven't changed
   - Processing data that won't be used
   - **Rule: Check if work is needed BEFORE doing it**

3. **Am I duplicating computation?**
   - Multiple event listeners doing the same raycast
   - Multiple passes over the same data
   - Recalculating instead of caching
   - **Rule: Compute once, reuse results**

4. **Can I consolidate operations?**
   - Multiple raycasts → Single raycast with multiple result consumers

5. **Should I precompute common operations?**
   - Precompute common parameter values (e.g., bucket sizes 1x-32x) for instant switching
   - Trade-off: Small memory cost (~10-15 MB) for dramatically better UX
   - **Rule: Precompute when memory cost is low and UX benefit is high**
   - Example: Bucketing cache allows instant bucket size changes without recomputation

6. **Have I quantified the trade-offs?**
   - Estimate memory usage before implementing optimizations
   - Calculate time savings vs memory cost
   - **Rule: Measure before optimizing - quantify memory, time, complexity trade-offs**
   - Example: ~10 MB RAM for cached bucket sizes = acceptable for instant UX improvement

**Examples of What to Catch:**

**BAD - Multiple raycasts per event:**
```javascript
// Three separate listeners, three raycasts!
element.addEventListener('mousemove', (e) => {
    updateHUD(e);  // Does raycast #1
});
element.addEventListener('mousemove', (e) => {
    checkHover(e);  // Does raycast #2
});
element.addEventListener('mousemove', (e) => {
    updateCursor(e);  // Does raycast #3
});
```

**GOOD - Single raycast, shared results:**
```javascript
element.addEventListener('mousemove', (e) => {
    const intersects = raycaster.intersectObjects(scene.children);
    updateHUD(intersects);
    checkHover(intersects);
    updateCursor(intersects);
});
```

**BAD - Doing work when nothing needs it:**
```javascript
// Always raycasts terrain, even when HUD is hidden!
function onMouseMove(e) {
    const world = raycastToWorld(e);
    updateHUD(world);  // HUD might be hidden!
}
```

**GOOD - Skip work when not needed:**
```javascript
function onMouseMove(e) {
    if (!hudVisible && !hasInteractiveElements) {
        return;  // Skip entirely
    }
    const intersects = doRaycast(e);
    if (hudVisible) updateHUD(intersects);
    // ... other systems
}
```

**When to Raise Performance Concerns:**

- **BEFORE implementing** - If something feels wasteful, question it
- **When you see duplication** - Multiple listeners, multiple loops, multiple queries
- **In event handlers** - mousemove/wheel/scroll fire 60+ times/second
- **When conditionals exist** - If a system might be disabled, check before computing

**What to Say:**

- "This will do X raycasts per mousemove - should we consolidate?"
- "The HUD might be hidden - should we skip this work?"
- "I see three listeners doing similar work - can we combine them?"
- "This rebuilds geometry on every change - can we use uniforms instead?"

**Don't implement first, ask later. Question inefficiency upfront.**

### Event Handler Patterns - Common Hot Paths

**These handlers fire 60+ times per second. Every millisecond counts.**

#### Animation Loops (requestAnimationFrame)

**Pattern: Coalesce rapid updates, apply once per frame**
```javascript
let pendingUpdate = null;

function requestTerrainUpdate(newValue) {
    pendingUpdate = newValue;  // Don't process immediately
}

function animate() {
    if (pendingUpdate !== null) {
        applyUpdate(pendingUpdate);  // Process once per frame
        pendingUpdate = null;
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
```

#### Conditional System Checks

**CRITICAL: Check visibility/state BEFORE computing**
```javascript
// BAD - Always computes, might not be used
function onMouseMove(e) {
    const world = raycastToWorld(e);  // Expensive!
    if (hudVisible) {
        updateHUD(world);  // Might be false
    }
}

// GOOD - Skip computation if not needed
function onMouseMove(e) {
    if (!hudVisible) return;  // Early exit
    const world = raycastToWorld(e);
    updateHUD(world);
}
```

### Environment
- Always use Python 3.13 virtual environment (`venv`)
- Activate with `.\venv\Scripts\Activate.ps1` in PowerShell
- Dependencies managed via `requirements.txt`
- **Setup Script**: `.\setup.ps1` automatically installs Python 3.13 via winget (if available) or requires manual installation
- **IDE Setup**: `.vscode/settings.json` configures Cursor/VS Code to use the venv Python interpreter
  - Python path: `venv/Scripts/python.exe`
  - Venv path: `venv` (folder containing virtual environment)
  - Search exclusions: `generated/**` and `.vscode/**` excluded from search results
  - Reload window after setup if IDE doesn't recognize packages

### Configuration Management

**PREFER configuration files over environment variables.**

- **Primary pattern**: Use never-checked-in config files (e.g., `settings.json`) with gitignored templates (e.g., `settings.example.json`)
- **Why avoid environment variables**: Hard to debug (invisible in code), platform-specific setup, easy to misconfigure
- **When environment variables are OK**: Deployment environments, CI/CD pipelines, Docker - only when absolutely necessary
- **This project's pattern**:
  - API keys and secrets go in `settings.json` (gitignored)
  - Template provided as `settings.example.json` (checked in)
  - Code reads from config file, not from `os.environ`

### Code Style
- **Python indentation**: This project uses 1-space indentation (non-standard) for compactness - maintain consistency
- Use type hints for function parameters and returns
- Keep functions focused and single-purpose
- Document complex data transformations with inline comments
- Use meaningful variable names (prefer `elevation_data` over `ed`)
- Use compact section headers: `//-------SECTION NAME-------` (not verbose box-style headers)
- Avoid repetitive comments that just restate parameter names (if param is `colorScheme`, don't add `// Color scheme`)

### Type Safety and Enums
- **Use enums for closed sets**: When you have a fixed set of string values (types, categories, states), use `enum.Enum`
- **String enums for serialization**: Inherit from `str` for JSON compatibility: `class MyEnum(str, Enum)`
- **Centralized location**: Place project-wide enums in `src/types.py`
- **When NOT to use enums**: Open-ended values (resolutions: 10m, 30m, future 5m), dual-nature fields (string for files, int for math)
- **Alternative**: Use `typing.Literal['value1', 'value2']` for type hints without runtime overhead
- **Example**: `RegionType` enum with USA_STATE, COUNTRY, AREA values

### Region Type System (CRITICAL - ABSOLUTE ENFORCEMENT)

**CANONICAL REFERENCE**: See `.cursorrules` - Section "Region Type System (CRITICAL - ABSOLUTE ENFORCEMENT)"

**ABSOLUTE RULE**: ALL code handling region types MUST use the `RegionType` enum from `src/types.py`.

```python
from src.types import RegionType

class RegionType(str, Enum):
    USA_STATE = "usa_state"  # US states
    COUNTRY = "country"      # Countries
    AREA = "area"            # Islands, ranges, custom areas
```

**ENFORCEMENT CHECKLIST**:
1. Import `RegionType` enum at top of file
2. Use enum values: `RegionType.USA_STATE` (NOT strings like `'us_state'`)
3. Check all three cases exhaustively with if/elif/elif/else
4. Raise `ValueError` for unknown types (NEVER silent fallback to None/default)

**FORBIDDEN PATTERNS**:
```python
# WRONG - String literals
if region_type == 'us_state':
if region_type == 'international':  # Not even an enum value!

# WRONG - Silent fallback
else:
    boundary_name = None  # Hides bugs!
```

**CORRECT PATTERN** (mandatory):
```python
from src.types import RegionType

if region_type == RegionType.USA_STATE:
    boundary_name = f"United States of America/{state_name}"
    boundary_type = "state"
elif region_type == RegionType.COUNTRY:
    boundary_name = country_name if clip_boundary else None
    boundary_type = "country" if clip_boundary else None
elif region_type == RegionType.AREA:
    boundary_name = region_name if clip_boundary else None
    boundary_type = None
else:
    raise ValueError(f"Unknown region type: {region_type}")
```

**WHY THIS MATTERS**: The bug we just fixed (Idaho not getting state borders) happened because code used ad-hoc strings (`'us_region'` vs `'us_state'`) that never matched, causing silent fallback to no clipping. The enum system prevents this class of bugs.

---

### Resolution Determination (CRITICAL - ABSOLUTE ENFORCEMENT)

**NOTE**: This section is about **elevation_resolution** (elevation data quality). For **border_resolution** (boundary detail level), see "Border Resolution" section below and "Resolution Naming Convention" section.

**CANONICAL REFERENCE**: See `.cursorrules` - Section "Resolution Determination (CRITICAL - ABSOLUTE ENFORCEMENT)"

**ABSOLUTE RULE**: Elevation data resolution is NEVER hardcoded by region type. It is ALWAYS dynamically determined using Nyquist sampling.

**Process** (see `src/downloaders/orchestrator.determine_required_resolution_and_dataset()`):
1. **FIRST**: Calculate visible pixel size from geographic bounds + target_total_pixels
   - Calculate base dimension: `base_dimension = sqrt(target_total_pixels)`
   - `visible_m_per_pixel = geographic_span_meters / base_dimension`
   - This determines what resolution we'll have in the final output
2. **THEN**: Apply Nyquist rule to determine minimum required source resolution
   - `min_resolution <= visible_m_per_pixel / 2.0`
   - Selects coarsest available resolution that meets requirement (prevents over-downloading)
3. **FINALLY**: Map resolution to dataset code (USA_3DEP, SRTMGL1, etc.)

**CRITICAL**: This order ensures we don't over-download. If final output needs 200m/pixel, we select 90m source (not 10m), because 200/90 = 2.22x > 2.0x Nyquist requirement.

**Available Elevation Data Resolutions** (NOT border resolutions - see "Resolution Naming Convention" section):
- `RegionType.USA_STATE`: `[10m, 30m, 90m, 250m, 500m, 1000m]` (USGS 3DEP + OpenTopography + GMTED2010)
- `RegionType.COUNTRY`: `[30m, 90m, 250m, 500m, 1000m]` (OpenTopography + GMTED2010)
- `RegionType.AREA`: `[10m, 30m, 90m, 250m, 500m, 1000m]` if US, else `[30m, 90m, 250m, 500m, 1000m]`

**GOAL**: Always deliver the right amount of accurate pixels for regions of all sizes (large, medium, small, tiny). The system automatically selects the coarsest resolution that meets Nyquist requirements, preventing over-downloading while ensuring quality.

**GMTED2010 Status**: GMTED2010 downloaders (250m, 500m, 1000m) support pre-downloaded files. Automated download not yet implemented - users can manually download from USGS EarthExplorer and place tiles in `data/raw/gmted2010_{resolution}/tiles/`. The system will automatically detect and use them. This enables efficient handling of very large regions (e.g., California with 1005m/pixel → selects 500m GMTED2010 instead of 90m SRTM).

**Example (Idaho)**:
```
target_total_pixels=262144 (512²):  visible=1292m/px -> requires 1000m (1292/1000=1.29x < 2x) -> requires 500m (1292/500=2.58x > 2x OK)
target_total_pixels=4194304 (2048²): visible=323m/px  -> requires 250m (323/250=1.29x < 2x) -> requires 90m (323/90=3.6x > 2x OK)
target_total_pixels=16777216 (4096²): visible=162m/px  -> requires 90m (162/90=1.8x < 2x) -> requires 30m (162/30=5.4x > 2x OK)
target_total_pixels=67108864 (8192²): visible=81m/px   -> requires 30m (81/30=2.7x > 2x OK) [US can use 10m but 30m sufficient]
```

**Example (California - large region)**:
```
target_total_pixels=1048576 (1024²): visible=1005m/px -> requires 500m (1005/500=2.01x > 2x OK) [Perfect match!]
target_total_pixels=4194304 (2048²): visible=502m/px  -> requires 250m (502/250=2.01x > 2x OK) [Perfect match!]
```

**FORBIDDEN ASSUMPTIONS**:
- [NO] "US states always use 10m" - FALSE, depends on target_total_pixels
- [NO] "International regions always use 30m" - FALSE, depends on target_total_pixels
- [NO] "Small states need high resolution" - FALSE, depends on output size, not geographic size

**WHY THIS MATTERS**: 
- Hardcoding resolutions wastes storage (downloading unnecessary 10m data when 500m would suffice for large regions)
- Over-downloading wastes bandwidth and storage (1000m/pixel output doesn't need 10m source data)
- The system automatically selects optimal resolution based on actual viewer needs (target_total_pixels + geographic bounds)
- Single source of truth prevents duplication and ensures consistency
- **GOAL**: Always deliver the right amount of accurate pixels for regions of all sizes (large, medium, small, tiny)

---

### Resolution Naming Convention (CRITICAL - ABSOLUTE ENFORCEMENT)

**TWO COMPLETELY SEPARATE CONCEPTS - NEVER CONFUSE THEM:**

#### 1. **elevation_resolution** (also called "data resolution" or "elevation data resolution")
- **Values**: `10m`, `30m`, `90m`, `250m`, `500m`, `1000m`
- **What it is**: Elevation data quality/sampling density (e.g., SRTM 30m, USGS 3DEP 10m, GMTED2010 500m)
- **How determined**: Dynamically by Nyquist sampling rule based on `target_total_pixels`
- **Where used**: 
  - File naming (e.g., `bbox_N37_W114_N42_W109_srtm_30m_30m.tif`)
  - Dataset selection (which elevation source to download)
  - Quality requirements (minimum resolution needed)
- **Variable naming**: Use `elevation_resolution` or `data_resolution` in code
- **Function parameters**: `min_required_resolution` (int, in meters: 10, 30, 90, 250, 500, 1000)

#### 2. **border_resolution** (also called "boundary detail level")
- **Values**: `10m`, `50m`, `110m` (as strings: `'10m'`, `'50m'`, `'110m'`)
- **What it is**: Natural Earth administrative boundary detail level
- **How determined**: Always `'10m'` in production pipeline (hardcoded)
- **Where used**:
  - Border clipping operations (`src/pipeline.clip_to_boundary()`)
  - Boundary geometry loading (`src/borders.BorderManager` methods)
  - Border export for viewer (`export_borders_for_viewer.py`)
- **Variable naming**: ALWAYS use `border_resolution` (never just `resolution`)
- **Function parameters**: `border_resolution` (str: `'10m'`, `'50m'`, `'110m'`)

#### Code Examples:

**CORRECT - Clear distinction:**
```python
# Elevation data resolution (dynamic, based on Nyquist)
elevation_resolution = '30m' if '30m' in source else '90m' if '90m' in source else '10m'
filename = f"bbox_{bounds}_srtm_{elevation_resolution}.tif"

# Border resolution (always 10m in production)
border_resolution = '10m'  # Hardcoded for production
geometry_gdf = border_manager.get_country(boundary_name, border_resolution=border_resolution)
```

**WRONG - Ambiguous naming:**
```python
# BAD - "resolution" is ambiguous - which type?
resolution = '30m'  # Is this elevation or border?
geometry = border_manager.get_country(name, resolution=resolution)  # Wrong parameter name!
```

#### Enforcement Rules:
1. **NEVER use `resolution` as a parameter name** - always specify `elevation_resolution` or `border_resolution`
2. **In `src/borders.py`**: All methods use `border_resolution` parameter (NOT `resolution`)
3. **In `src/pipeline.py`**: Local variables for elevation data use `elevation_resolution` (NOT `resolution`)
4. **When calling border methods**: Always use `border_resolution=...` keyword argument
5. **When documenting**: Always specify which type of resolution you mean

#### Why This Matters:
- Prevents bugs from confusing elevation data quality with boundary detail level
- Makes code self-documenting (clear what each variable represents)
- Enables proper type checking (elevation_resolution is int in meters, border_resolution is str)
- Prevents accidental misuse (e.g., passing elevation resolution to border methods)

---

### Terminology Consistency
- **One term per concept**: Never use synonyms for the same thing (e.g., not both "category" and "region_type")
- **Unify immediately**: When you notice dual terminology, refactor to single term before it spreads - IF you are sure it really is the same thing! If in doubt, check or ask

### Import Safety - CRITICAL RULE

**NEVER use defensive imports with fallbacks. Let imports fail hard.**

#### What This Means:
- **No `try/except ImportError`** for internal code (your own modules)
- **No `try/except ImportError`** for required external libraries (rasterio, numpy, shapely, etc.)
- **No conditional imports** (`if X: import A else: import B`)
- **No fallback implementations** that work around missing imports

#### Examples of BANNED patterns:
```python
# BAD - Defensive import with fallback
try:
    import rasterio
except ImportError:
    print("Install rasterio: pip install rasterio")
    sys.exit(1)

# BAD - Conditional import with alternative
try:
    from src.borders import get_border_manager
except ImportError:
    # Use alternative implementation
    from src.legacy_borders import get_border_manager

# BAD - Optional feature with import fallback
try:
    import optional_library
    HAS_FEATURE = True
except ImportError:
    HAS_FEATURE = False
```

#### CORRECT pattern:
```python
# GOOD - Just import directly, let Python handle errors
import rasterio
from rasterio.mask import mask as rasterio_mask
import numpy as np
from src.borders import get_border_manager
```

#### Why This Rule Exists:
1. **Hides real errors**: Defensive imports mask configuration and dependency issues
2. **Allows duplication**: Alternative implementations proliferate instead of fixing root cause
3. **Confuses dependencies**: Unclear what's actually required vs optional
4. **Poor error messages**: Custom error messages are worse than Python's native ImportError

#### Exception - Test Files Only:
Test files that explicitly check if imports work are OK (e.g., `test_import_works()`), but these should be in test suites, not production code.

#### If Import Fails:
1. **Check `requirements.txt`** - Is the package listed?
2. **Install dependencies** - Run `pip install -r requirements.txt`
3. **Fix the import path** - If it's an internal module, fix the path or structure
4. **Never add try/except** - Fix the root cause instead

#### After Refactoring:
Use grep to find ALL import statements of moved functions:
```bash
grep -r "from src.module import function_name" .
```
Update all imports - don't add defensive fallbacks to old paths.

### Frontend/Web Viewer
- **jQuery**: Keep it. jQuery is widely cached and makes code more readable. Avoid Select2; use native or custom dropdowns matching the region selector pattern.
- **CSS styling**: Avoid inline styles. Use rationally-named CSS classes instead. **CRITICAL**: Inline styles (`element.style.cssText` or `element.style.property`) override CSS with highest specificity - always check JS for inline styles when CSS changes don't apply.
- **File organization**: Separate HTML and JS into different files rather than mixing them.
- **Code reuse**: Don't duplicate code, but also don't force artificial reuse when use cases actually differ. Balance DRY with clarity.
- **Recent regions**: Max 12 items, most recent first. On region load, move to front of list (deduplicates automatically).

#### UI Control Organization
- **Bidirectional controls**: Split into two clear columns with user-friendly labels (e.g., "HIGHER DETAIL" vs "LOWER DETAIL")
- **Visual hierarchy**: Use color-coded headers to distinguish control groups (green = higher detail, orange = lower detail)
- **Button layout**: Vertical stacking within columns works better than horizontal wrapping
- **Quick access buttons**: Provide MAX and DEFAULT buttons for common settings (bucket size 1 and auto-calculated optimal)
- **Labels**: Use conceptual names over technical terms (e.g., "Resolution" not "Bucket Size")

### Data Handling
- Store raw data in `data/` directory (gitignored)
- Within there, store items of different types in a distinguishable way; for example, each file type should be able to be detected.
- Cache processed data to avoid re-downloading (including masked/bordered data)
- Always validate data ranges and handle missing values
- GeoTIFF data uses natural orientation (North up, East right) - no transformations needed
- Use geopandas for geographic borders and masking operations

#### Multiple Data Sources - Download Rules (CRITICAL)

**Tile Size Standards**:
- **ALWAYS use 1×1 degree standard tiles** for ALL data sources
- Print in output: "Tile size: 1×1 degree (standard grid)"
- Print storage: "Storage: data/raw/{source}/tiles/ (region-specific downloads, no reuse)"
- Never use arbitrary tile sizes - 1×1 degree is the universal standard

**API Key Checking (BEFORE Downloads)**:
- **Check API keys BEFORE starting any downloads** - don't wait for first failure
- Print clear warning if API key missing
- Show setup URL: "Get free API key at: https://portal.opentopography.org/"
- Show setup instructions: Add to settings.json format
- Continue with sources that don't require API keys

**Error Reporting (EVERY Failure)**:
- For EVERY download failure, print: reason, URL (if applicable), full details
- Return `(success: bool, error_message: str)` from download functions
- Collect ALL errors when multiple sources fail
- Print detailed report showing EACH source tried and WHY it failed
- Example format:
  ```
  ALL SOURCES FAILED FOR TILE
  Tile: (-98, 43, -97.0, 44.0) (1×1 degree standard tile)
  Errors by source:
    - SRTM 90m: No API key configured
    - Copernicus S3: Tile not available (404): https://...
  ```

**Abort on Critical Failure**:
- If ALL sources fail for a tile, abort immediately
- Don't continue downloading remaining tiles - merge will fail anyway
- Print clear error message explaining the critical failure

**Copernicus S3 Structure (CRITICAL)**:
- Tiles are in DIRECTORIES, not direct files
- URL structure: `https://copernicus-dem-{res}m.s3.amazonaws.com/{tile_name}/{tile_name}.tif`
- Resolution in path is ARC-SECONDS, not meters:
  - GLO-30 (30m data) = `10` arc-seconds in path
  - GLO-90 (90m data) = `30` arc-seconds in path
- Example: `https://copernicus-dem-90m.s3.amazonaws.com/Copernicus_DSM_COG_30_N43_00_W098_00_DEM/Copernicus_DSM_COG_30_N43_00_W098_00_DEM.tif`
- Only GLO-30 and GLO-90 are publicly available via S3 (no GLO-10)

#### Data Flow Directories
- **`data/raw/{source}/tiles/`** - 1×1 degree tiles (region-specific downloads, no reuse)
- **`data/merged/{source}/`** - Region-specific merged files (intermediate output from tile merging)
- **`data/processed/{source}/`** - Clipped/reprojected files (pipeline intermediate stage)
- **`data/borders/`** - Natural Earth border data (canonical, stable, not cache)
- **`generated/regions/`** - Final JSON exports for web viewer
- **Why separate directories**: Organizes data by processing stage (raw → merged → processed → exported)

#### Resolution Requirements (CRITICAL)
- **Universal rule**: ALL regions use Nyquist sampling rule based on visible pixel size
- **No type-based exceptions**: Region type (USA_STATE/COUNTRY/AREA) does NOT dictate quality requirements
- **Region type is for**:
  - Download routing (which API/source to use)
  - UI organization (dropdown grouping in viewer)
- **Region type is NOT for**:
  - Quality requirements (universal rules apply)
  - Resolution selection (based on actual data needs)

#### Border Resolution (CRITICAL)
- **Parameter name**: Always use `border_resolution` (NOT `resolution`) - see "Resolution Naming Convention" section above
- **Always use 10m resolution borders** for accurate clipping (Natural Earth 10m dataset)
- 110m borders are TOO COARSE and miss islands/coastline details (e.g., Iceland missing 4 islands!)
- Border quality comparison:
  - 10m: High detail, captures all islands and accurate coastlines (always used in production pipeline)
  - 50m: Medium detail (only in utility scripts for testing)
  - 110m: Low detail, misses features (DO NOT USE for production)
- **Production pipeline**: Border resolution is hardcoded to 10m in `ensure_region.py` (not configurable)
- **Utility scripts**: `download_borders.py` and `export_borders_for_viewer.py` may allow other resolutions for testing
- **All border methods**: Use `border_resolution` parameter (see `src/borders.py` for examples)

#### Tile System (Region-Specific Downloads)

**CANONICAL REFERENCE**: See `.cursorrules` - Section "Tile System (Region-Specific Downloads)"

**Format**: `{NS}{lat}_{EW}{lon}_{elevation_resolution}.tif`
**NOTE**: The `{elevation_resolution}` in filenames refers to elevation data resolution (10m/30m/90m), NOT border resolution.

**Examples**:
- `N35_W090_30m.tif` (35°N, 90°W, 1° × 1°, 30m elevation data resolution)
- `S05_E120_90m.tif` (5°S, 120°E, 1° × 1°, 90m elevation data resolution)

**Storage**:
- `data/raw/usa_3dep/tiles/` - 10m USGS tiles
- `data/raw/srtm_30m/tiles/` - 30m SRTM tiles
- `data/raw/srtm_90m/tiles/` - 90m SRTM tiles

**Key**: All regions use unified 1-degree tile system for organization. Tiles are downloaded fresh for each region at the required resolution (no reuse).

#### File Naming Philosophy: Abstract vs Specific

**Core Principle**: Use naming schemes that match the reusability and purpose of the data. The choice between abstract bounds-based naming and region_id-based naming should reflect whether the data is reusable global data or viewer-specific exports.

**Abstract Bounds-Based Naming** (for reusable global data):
- **Use for**: Raw downloads, processed GeoTIFFs, clipped data that could be shared across regions
- **Format**: `bbox_{bounds}_{dataset}_{elevation_resolution}.tif` (e.g., `bbox_N37_W114_N42_W109_srtm_30m_30m.tif`)
**NOTE**: The `{elevation_resolution}` refers to elevation data resolution (10m/30m/90m), NOT border resolution.
- **Why**: Enables content-based reuse - multiple regions can share same raw/processed files
- **Examples**: 
  - Raw bbox downloads: `data/raw/srtm_30m/bbox_{bounds}_{dataset}_{res}.tif`
  - Processed GeoTIFFs: `data/processed/{source}/{base_part}_processed_{pixels}px_v2.tif`
  - Clipped files: `data/clipped/{source}/{base_part}_clipped_{hash}_v1.tif`

**Region-Specific Naming** (for viewer exports and filtered data):
- **Use for**: Exported JSON files for web viewer, any data already filtered/clipped to specific boundaries
- **Format**: `{region_id}_{source}_{pixels}px_v2.json` (e.g., `ohio_srtm_30m_2048px_v2.json`)
- **Why**: These are viewer-specific exports that are already clipped to specific boundaries and filtered. They're not reusable across regions - each region has its own filtered/clipped export.
- **Examples**:
  - Viewer JSON exports: `generated/regions/{region_id}_{source}_{pixels}px_v2.json`
  - Manifest references files by `region_id` → filename mapping

**Decision Tree**:
1. Is the data **reusable across multiple regions** (same bounds, same source)? → Use abstract naming
2. Is the data **already filtered/clipped to specific boundaries** and viewer-specific? → Use region_id naming
3. Is the data a **final export for a specific use case** (viewer, visualization)? → Use region_id naming

**Data Hierarchy Understanding**:
- **Raw files** (`data/raw/`): Source of truth - preserve exactly as downloaded. These enable regeneration of all downstream files. Use abstract naming for reuse potential.
- **Processed files** (`data/clipped/`, `data/processed/`): Can regenerate from raw. Use abstract naming for reuse potential.
- **Exported files** (`generated/regions/`): Final viewer exports - use region_id naming since they're viewer-specific and already filtered.

#### Core Data Principles - CRITICAL

**Principle 1: Preserve Real-World Proportions**

Our goal is to accurately represent geographic data with correct proportions. A wide state like Tennessee (8.7° wide × 1.7° tall) must appear wide, not square. A tall state like New Jersey must appear tall.

**Implementation**: When masking to administrative boundaries (states/countries), crop the output to the actual shape boundaries, not the rectangular bounding box. This removes empty space that would distort aspect ratios.

**Standard Pipeline Flow** (in `src/pipeline.py`):
1. **Download** raw elevation data (bounding box, EPSG:4326)
2. **Clip** to boundary using `rasterio_mask()` with `crop=True` and `filled=False`
3. **Reproject** ALL EPSG:4326 regions to fix latitude distortion:
   - Always reproject (no exceptions - fixes distortion at ALL latitudes)
   - Reproject to EPSG:3857 (Web Mercator) to correct longitude compression
   - **CRITICAL**: Initialize output array with nodata, pass `src_nodata` and `dst_nodata` parameters
   - Example: Kansas (38°N) has 1.28x distortion, Iceland (65°N) has 2.37x distortion
4. **Downsample** to target resolution while preserving aspect ratio
5. **Export** to JSON with bounds converted back to EPSG:4326 for viewer

**Validation**: Export process automatically validates aspect ratio against geographic reality (see `src/validation.py`). Exports fail if proportions are >30% incorrect.

**Principle 2: Treat Input Data as Uniform 2D Grid**

Elevation data from GeoTIFFs is a simple 2D array of height values at evenly-spaced grid points. **Do not reinterpret or transform this data** based on latitude/longitude when rendering:

- **Correct**: Render as uniform square grid (each pixel = one unit of space)
- **Wrong**: Apply latitude-dependent scaling or geographic projections in the viewer

**Why**: The input data already has correct proportions built in (from the masking/cropping process). Adding transformations in the viewer would apply corrections twice, creating distortion.

**In the viewer (Three.js)**:
```javascript
// CORRECT - Simple uniform grid
const geometry = new THREE.PlaneGeometry(width, height, width-1, height-1);

// WRONG - Don't add geographic transformations
const widthMeters = lonSpan * cos(lat) * 111_320;  // NO!
const geometry = new THREE.PlaneGeometry(widthMeters, heightMeters, ...);
```

**In data export**: Ensure cropping produces correct aspect ratios so viewer needs no corrections.

**When downsampling**: Always use the **same step size for both dimensions**:
```python
# CORRECT - Preserves aspect ratio
# Calculate base dimension from total pixels, then use for step size
base_dimension = int(round(math.sqrt(target_total_pixels)))
step_size = max(1, int(math.ceil(max_dim / base_dimension)))
downsampled = elevation[::step_size, ::step_size]

# WRONG - Distorts aspect ratio
step_y = height // target_height  # Different
step_x = width // target_width    # Different
downsampled = elevation[::step_y, ::step_x]  # Distorts!
```

# Altitude Maps – Cursor Rules (Project-Specific Additions)

## Region Selector Grouping (Viewer)
- The region dropdown MUST use exactly three groups, in this order:
  1) Countries (international, alphabetical)
  2) Areas (non-country areas like islands/peninsulas/ranges, alphabetical)
  3) US states (alphabetical)
- Insert a visible divider (HR-style) between each group.
- Non-selectable divider entries should not be focusable or trigger selection.

## UI Responsiveness: Slider/Drag Debounce
**See "Performance-First Thinking" section for general principles. These are specific patterns for interactive controls.**

- Debounce expensive operations during continuous input (dragging sliders, rapid changes):
  - Recreating terrain meshes, recomputing normals, or other heavy rebuilds should be debounced (≈50–120 ms).
  - Apply immediate lightweight updates for responsiveness (e.g., height value updates) and coalesce heavy work.
- On input "change/end" events, perform a single prompt final update to settle state (e.g., compute normals once, or recreate if required by mode).

### GPU-Driven Rendering Updates (Performance Best Practices)
- Prefer GPU-side updates via shader uniforms over CPU loops or geometry rebuilds for continuous controls.
- Vertical exaggeration:
  - Use a uniform ratio relative to the build-time baseline (e.g., `uExaggeration = currentInternal / baselineInternal`).
  - Keep bar bottoms anchored with local-space offset: `transformed.y = transformed.y * uExaggeration + (uExaggeration - 1.0) * 0.5`.
  - Coalesce updates with `requestAnimationFrame`; cancel older frames and apply only the latest value.
- Tile gap (bars):
  - Scale X/Z in the shader with `uTileScale = currentTileSize / baselineTileSize`.
  - Update per frame during drag; rebuild bars only when the baseline changes (bucket size or aggregation change).
- Only bars mode is supported - all exaggeration updates use GPU uniforms.

### Render Modes Product Guidance
- Bars: Only render mode supported. Instanced meshes with GPU uniforms for exaggeration and tile gap; never rebuild for those sliders.
- Points: Removed from product - no longer supported.
- Wireframe: Not supported in product due to poor UX and build cost; if selected, map to bars.
- Surface: Removed from product - no longer supported.

### Implementation Patterns
- Store shader uniform references in `material.userData` for fast updates.
- Avoid verbose logging in hot paths; keep create/rebuild logs only.
- Maintain once-per-frame scheduling for all continuous sliders.

## Libraries
- Do not add fallback loaders. If a library load fails, fix the primary load path instead of conditionally swapping to alternates.


### Data Format Versioning & Cache Invalidation
--- You must clearly and explicitly state what each filetype is andhow  it works. Don't leave it disogranized.
**CRITICAL**: When changing data processing/export format:
1. **Update the format version number** in export scripts
2. **Add version validation** on data load (fail if version mismatch)
3. **Document the change** in code comments
4. **Re-export ALL cached/generated data** - don't mix old and new formats

Cached/Generated Data Locations:
- `data/.cache/` - Masked/bordered raster data (pickled)
- `generated/` - Exported JSON for web viewer
- `generated/regions/` - Per-region exported data

To invalidate all caches after format changes:
```powershell
# Delete cached data
Remove-Item -Recurse -Force data\.cache\*
Remove-Item -Recurse -Force generated\*

# Re-export from source GeoTIFFs
python ensure_region.py <region_id> --force-reprocess
```

### Visualization
- Save outputs to `output/` directory
- Create both static (matplotlib) and interactive (plotly) versions when appropriate
- Use clear, colorblind-friendly color schemes
- Add proper titles, labels, and legends
- Include data source citations in visualizations
- **Vertical Exaggeration**: Uses real-world scale where 1.0 = true Earth proportions, 2.0 = mountains twice as steep as reality. Both X/Z (horizontal) and Y (elevation) axes are in meters based on lat/lon bounds.

### 3D Rendering (Three.js)

**Camera Near/Far Planes**:
- Maintain ratios < 1,000,000:1 (current: `near=1, far=100000`)
- Extreme ratios cause depth buffer artifacts (distant geometry bleeds through nearby)
- Never use `near < 0.1` or `far > 1,000,000` - depth buffer loses precision

**Coordinate Space Architecture**:
- Scene hierarchy: `scene → terrainGroup → terrainMesh → bars`
- Objects rotating with terrain → `terrainGroup.add(object)` (NOT `scene`)
- World-fixed objects (camera, lights, UI) → `scene.add(object)`
- Bug: Objects in wrong parent appear misaligned and don't rotate correctly

**Reprojection Pattern**:
- Always initialize arrays with nodata before reprojecting: `reprojected.fill(nodata_value)`
- Always pass `src_nodata` and `dst_nodata` parameters to `reproject()`
- Uninitialized arrays + missing nodata = data corruption (millions of zero/negative values)

**Downsampling Pattern**:
- Use SAME step size for both dimensions: `step_size = max(1, int(ceil(max_dim / target_pixels)))`
- Different step sizes distort aspect ratio (wide states become square)
- Pattern: `downsampled = elevation[::step_size, ::step_size]`

**Aspect Ratio Preservation**:
- Use `crop=True` in `rasterio_mask()` to remove empty bounding box space
- Treat input data as uniform 2D grid in viewer (no geographic transformations)
- Data already has correct proportions from export - don't "correct" twice

**Cache and Versioning**:
- Filename-based versioning: `{region}_{source}_{pixels}px_v2.json`
- Strict regeneration policy: Never mix old and new format files
- When format changes: Bump version, regenerate ALL files, delete old versions
- Manifest selection: Strict v2-only selection, fail-fast on version mismatch (no silent fallbacks)

**Manifest File Selection**:
- Never use "first file alphabetically" - always prefer v2 files
- Fail-fast if multiple versions exist - don't silently fall back to old files
- Validate version field in JSON before selecting

**JSON Export Performance**:
- Use vectorized NumPy operations: `mask = np.isnan(arr); arr_obj = arr.astype(object); arr_obj[mask] = None; arr_obj.tolist()`
- Never use nested Python loops for array conversion - 28x slower

**Resampling Quality**:
- Nyquist rule: Need >=2.0x oversampling to avoid aliasing
- Threshold: 90m source sufficient if visible pixels >= 180m (2x safety margin)
- Use bilinear interpolation for continuous elevation data

**Region Switching Lifecycle**:
- Clear marker arrays when destroying terrain: `edgeMarkers.length = 0`
- Centralized lifecycle management in terrain renderer
- Destroy old terrainGroup first, then clear arrays, then create new

**Adjacency Deduplication**:
- Diagonal neighbors appear in multiple directions - deduplicate by longest shared border
- Keep only the "most adjacent" occurrence (longest border length)

**Rendering Efficiency**:
- Enable frustum culling: Three.js computes bounds once, skips off-screen instances
- GPU depth testing is automatic - no manual occlusion culling needed
- Instanced rendering: One draw call for all bars

**Code Quality Principles**:
- Question defensive patterns: Trust architecture if dependencies are guaranteed
- Consolidate before optimizing: Duplication is worse than performance
- Genericize closed sets: Use data-driven patterns instead of hardcoding cases
- Remove unnecessary complexity: Complexity must solve a real problem
- Organize by purpose, not type: Group by logical purpose (CORE STATE, DATA STATE)
- Cache expensive computations, not simple lookups: Cache what's expensive to compute
- Comments explain why, not what: Skip comments for self-explanatory code
- Constants for magic values: Even if used 2-3 times, constants provide single source of truth
- Module boundaries matter: Functions belong with related functionality

**Ground Plane Camera Model**:
- Fixed reference plane at y=0 (map surface)
- Focus point anchored ON the plane (where camera looks)
- All operations relative to this plane
- Pan: Slides focus point along plane, camera follows parallel
- Zoom: Moves camera perpendicular to plane toward/away from focus point
- Rotate: Orbits around focus point on plane

**Camera URL Persistence**:
- Use `replaceState()` not `pushState()` - avoids cluttering browser history
- Update URL only when camera stops moving AND mouse buttons released
- Frame-to-frame comparison detects movement end
- Optional parameters omitted if at defaults (reduces URL clutter)

**Vertical Exaggeration**:
- Use real-world meters for both horizontal and vertical axes
- Calculate from geographic bounds: `meters_per_deg = 111_320 * cos(lat)`
- 1.0x = true Earth scale (1000m horizontal = 1000m vertical)
- Default: 4.0x (moderately dramatic)

**Border System**:
- Use Natural Earth admin_0 (countries) and admin_1 (states/provinces)
- Always use 10m resolution borders for production (50m/110m miss features)
- Cache borders in `data/.cache/borders/` for reuse
- Border clipping: Use `crop=True` in `rasterio_mask()` to remove empty space

**Modular Architecture**:
- Expose window globals: `window.scene`, `window.camera`, `window.params`, `window.processedData`
- Verify script loading order: Libraries → utilities → modules → main viewer
- Module initialization: After globals are set up
- Defensive checks: `typeof functionName === 'function'` before calling

**Compass Label Rotation**:
- Don't restore terrain rotation before creating edge markers - markers positioned for zero rotation
- Create markers first, then apply rotation if needed
- Rotation state should reset on region switch, not persist across regions

**Unified Tiling System**:
- ALL resolutions (10m, 30m, 90m) ALWAYS use 1-degree tile system
- No special cases based on region size - tiles for everything
- Prevents tile reuse issues and maintains consistency

**Type Stubs**:
- Suppress noisy type stub warnings in `.vscode/settings.json` for libraries without annotations
- Use diagnostic suppression rather than custom stubs (more reliable)

**Bar Rendering**:
- Use rectangular bars matching actual grid spacing: `BoxGeometry(widthX, 1, depthZ)` not `BoxGeometry(size, 1, size)`
- Bars must match bucketed spacing to prevent gaps/overlaps
- Remove zoom out limits: `maxDistance = Infinity` for infinite zoom

**Versioning Simplification**:
- Filename IS the version: `{region}_{source}_{pixels}px_v2.json`
- No redundant version fields inside JSON files
- One source of truth (filename) is cleaner than duplication

**Documentation Consolidation**:
- Eliminate duplication: One doc per topic, canonical reference wins
- Validate against actual functionality: Read code, not assumptions
- All technical guidance consolidated in `.cursorrules` - no separate learnings files

**Adjacency Simplification**:
- Use 4-cardinal directions (90-degree sectors) instead of 8-way with deduplication
- Each neighbor appears in exactly one direction - no deduplication needed
- Compute from geographic boundaries, not hardcoded data

**Windows Development**:
- Wrap stdout/stderr with UTF-8 TextIOWrapper for proper encoding
- Use pathlib.Path for cross-platform paths
- Prefer pure Python libraries over native dependencies when possible

**Unified Tiling System**:
- ALL resolutions (10m, 30m, 90m) ALWAYS use 1-degree tile system
- No special cases based on region size - tiles for everything
- Prevents tile reuse issues and maintains consistency

**Aspect Ratio Preservation**:
- Use same step size for both dimensions when downsampling: `step_size = max(1, int(ceil(max_dim / target_pixels)))`
- Different step sizes distort aspect ratio (wide states become square)
- Validate aspect ratio before export: `abs(export_aspect - source_aspect) > 0.01` raises error

**Modular Architecture Verification**:
- Expose window globals: `window.scene`, `window.camera`, `window.params`, `window.processedData`
- Verify script loading order: Libraries → utilities → modules → main viewer
- Module initialization: After globals are set up
- Defensive checks: `typeof functionName === 'function'` before calling

**UI Label Placement**:
- Edge markers (N/S/E/W): At terrain edges, ground level
- Connectivity labels: Below edge markers, negative Y
- Containment navigation: Use fixed 2D panel (not 3D labels) for discoverability
- Small areas: Fixed screen-space "back" button prevents obscuration

**Resolution Selection**:
- Calculate visible pixel size before download: `base_dimension = sqrt(target_total_pixels)`, then `visible_m_per_pixel = geographic_span_meters / base_dimension`
- Use Nyquist rule: `source_resolution <= visible_pixel_size / 2.0` for >=2.0x oversampling
- >=180m visible: Recommend 90m (Nyquist safe)
- <90m visible: Automatically use 30m

#### Performance Tuning
- **Default bucket size**: Auto-adjust targets ~3,900 buckets (not 10,000) for better initial performance
- **User can refine**: Provide granular controls (-10/-5/-1/+1/+5/+10) for users who want more detail
- **Performance over quality**: Start conservative (larger buckets), let users increase detail if they want
- **Rationale**: Better to load fast with decent quality than slow with perfect quality - users will adjust if needed

### Camera Controls - Custom (Default) Scheme
**Ground Plane Camera System** - The project's custom default camera controls, tested and confirmed buttery smooth. Users can switch to alternative schemes (Google Earth, Roblox Studio, Flying, Jumping, Blender, Unity Editor) via the Camera Controls dropdown, but this is the recommended default.

**Core Architecture (CRITICAL for smoothness):**
- Fixed ground plane at y=0 (the map surface)
- Focus point anchored ON the plane (where camera looks)
- All operations relative to this plane
- **camera.lookAt() called ONLY in update() loop** (once per frame, synchronized with rendering)
- **NEVER call camera.lookAt() in mouse event handlers** - this causes high-frequency jitter
- Mouse handlers only update positions; render loop handles orientation

**Control Behaviors:**

1. **Left Drag = Pan on Ground Plane**
   - Behavior: "Grab and drag" the map surface
   - Drag DOWN → map moves down, Drag UP → map moves up
   - Drag LEFT → map moves left, Drag RIGHT → map moves right
   - Implementation: Screen-space movement for smoothness (not continuous raycasting)
   - Speed: Adaptive based on distance from focus point (distance * 0.001)
   - Camera and focus point move together, maintaining view angle

2. **Shift + Left Drag = Tilt View (Pitch Adjustment)**
   - Behavior: Change viewing angle to see more/less terrain
   - Drag DOWN → tilt down (increase phi angle, see more land/horizon)
   - Drag UP → tilt up (decrease phi angle, more overhead view)
   - Implementation: Spherical coordinate adjustment around focus point
   - Angle limits: 0.1 to π/2 - 0.01 radians (prevents camera flip)
   - Tilt speed: 0.005 radians per pixel
   - Cancels smoothly if Shift released mid-drag (prevents jank)
   - Focus point stays fixed on ground plane

3. **Middle Drag = Rotate Map Around Origin**
   - Behavior: Orbit camera around origin (0,0,0)
   - Camera moves in a circular path, always looking at origin
   - Horizontal drag → rotate around vertical axis (orbit left/right)
   - Vertical drag → change viewing angle (orbit up/down)
   - Rotation speed: 0.005 radians per pixel
   - Angle limits: Prevents camera from flipping (0.1 to π - 0.1 radians)
   - Focus point stays at origin during operation

4. **Right Drag = Look Around (Rotate View in Place)**
   - Behavior: Rotate view direction without moving camera position
   - Camera position stays completely fixed (no movement)
   - Only the view direction changes (where you're looking)
   - Horizontal drag → turn left/right (yaw)
   - Vertical drag → look up/down (pitch)
   - Angle limits: Prevents looking straight up/down (max pitch ±89 degrees)
   - Rotation speed: 0.005 radians per pixel

5. **Alt + Left Drag = Rotate View Around Focus Point**
   - Behavior: Rotate view around focus point
   - Horizontal drag → turn left/right (rotate around vertical axis)
   - Vertical drag → tilt up/down (adjust viewing angle)
   - Implementation: Spherical coordinate transformation around focus point
   - Rotation speed: 0.005 radians per pixel
   - Maintains constant distance from focus point
   - Same angle limits as tilt to prevent camera flipping
   - Cancels smoothly if Alt released mid-drag (prevents jank)

6. **Mouse Wheel = Zoom Toward/Away From Cursor**
   - Behavior: Zoom toward point under cursor
   - Scroll UP (negative delta) → zoom IN = camera moves toward cursor point
   - Scroll DOWN (positive delta) → zoom OUT = camera moves away from cursor point
   - Zoom factor: 10% of distance per scroll tick
   - Minimum distance: 5 meters (prevents getting too close)
   - **Bidirectional focus shift (CRITICAL for smooth zoom):**
     - Zoom IN: Focus moves toward cursor (focusShift = +0.1)
     - Zoom OUT: Focus moves away from cursor (focusShift = -0.1)
     - This ensures camera AND focus move in same direction (no conflict)
   - Cursor point stays visually stable under mouse

7. **WASD/QE/F Keys = Keyboard Movement**
   - Behavior: Pure space movement - camera moves freely without orientation constraints
   - W = move forward in view direction
   - S = move backward
   - A = strafe left
   - D = strafe right
   - Q = move down (descend)
   - E = move up (ascend)
   - All movement maintains camera orientation (no auto-tilting or ground plane snapping)
   - Can fly through terrain geometry without sticking
   - **F = Reframe view** - Reset to fixed overhead map view:
     - Position: Fixed at (0, 2500, 2.5) looking at origin
     - Height: 2,200 units (close-up view)
     - Orientation: Rotated 180 degrees (North at top of screen, although the code is confused about this; what really shows is North despite fears.)
     - **AUTOMATIC BEHAVIOR**: Reframe is applied automatically whenever:
       - Initial page load completes (first region loaded)
       - User switches to a different region via dropdown
       - This ensures consistent, well-centered view every time data loads
     - Manual trigger: Press F key anytime to recenter
   - Works simultaneously with all mouse controls
   - Speed: Base 4.0 units/frame, accelerates which is kept as long as they're moving, no limit, but slow acceleration.
- **Disabled when typing:** WASD keys don't affect camera when typing in input fields, textareas, or dropdown inputs.

8. **Touch/Trackpad Gestures**
   - **Single finger drag** = Pan (mobile touch)
   - **Two-finger drag** = Pan (trackpad/desktop)
   - **Two-finger pinch** = Zoom in/out (pinch together = zoom in, spread apart = zoom out)
   - **Simultaneous pan + zoom** = Two-finger gesture supports both at once
   - Implementation: Touch event handlers with gesture recognition
   - Prevents default touch behavior to avoid page scrolling
   - Zoom sensitivity: 1% per pixel of pinch distance change
   - All gestures maintain ground plane model (focus stays at y=0)
   - Works on mobile devices (phones/tablets) and desktop trackpads (MacBook, etc.)

**Implementation Pattern (DO NOT DEVIATE):**
```javascript
// In mouse event handlers (onMouseMove, onWheel):
// 1. Calculate new camera position
this.camera.position.copy(newPosition);

// 2. Update focus point if needed
this.focusPoint.copy(newFocusPoint);

// 3. Update controls target
this.controls.target.copy(this.focusPoint);

// 4. DO NOT call camera.lookAt() here!
// The update() loop handles this once per frame

// In update() loop (called by requestAnimationFrame):
update() {
    if (this.enabled && this.focusPoint) {
        this.camera.lookAt(this.focusPoint); // ONLY place this is called
    }
}
```

**Why This Works:**
- Single source of truth for camera orientation (no fighting between handlers)
- Synchronized with render loop (60fps, no micro-stutters)
- Predictable timing regardless of input frequency
- Standard pattern used by Three.js OrbitControls and professional systems

**What NOT To Do:**
- Don't call camera.lookAt() in mouse handlers (causes jitter)
- Don't use continuous raycasting for pan (too slow/jerky)
- Don't make focus shift unidirectional (breaks zoom out feel)
- Don't forget to cancel operations if modifier keys released mid-drag
- Don't process keyboard shortcuts when user is typing in input fields
- Don't break existing controls when adding new features (additive only)

### Testing
- Test with small data samples first before processing large datasets
- Verify coordinate systems and projections
- Check data units and conversions
- Validate output visualizations manually

### Documentation
- Update README.md for major feature additions
- Significant learnings should be added to `.cursorrules` as high-level HOW/WHY guidance
- Keep inline code comments focused on "why" not "what"
- Never describe your own work as "stunning", "beautiful", "incredible" - don't be a braggart
- Be humble about work you've done, not ostentatiously humble, just light and clear
- Explain things as needed without self-praise
- **Bump version before ending session** - Run `python bump_version.py` after user-facing changes
- **User feedback validates UX improvements**: When users express strong positive feedback (e.g., "VERY good"), that validates the engineering effort was worth it. UX improvements that feel instant are worth the complexity.

**Technical Guidance Philosophy:**
- Add high-level HOW/WHY patterns to `.cursorrules`, not procedural steps
- Focus on project-specific constraints, patterns, and gotchas
- Example: "We need to watch for large files because geospatial data grows quickly and breaks git"
- NOT: "Here's the git command to remove large files from history"
- Think: What would future developers need to remember about this project's unique characteristics?

## Data Sources Strategy

### Elevation Data Priority (User Preference)

**USA - Always Use USGS 3DEP First:**
- Source: USGS 3D Elevation Program (3DEP)
- Resolution: 1-10m (far better than global sources)
- Coverage: Full USA
- Workflow: Download bounding box → Clip to state boundaries → Cache both
- Auth: May require API key (user will provide if needed)
- URL: https://elevation.nationalmap.gov/

**Global - Prefer Nation-Specific Sources:**
Priority order for any country:
1. **National agency data** (if available) - Always check first
   - Examples: Australia (Geoscience), Japan (GSI), Germany (BKG), UK (Ordnance Survey)
   - Often higher resolution and quality than global datasets
   - May require country-specific download process
2. **Global fallback sources** (if national unavailable):
   - OpenTopography SRTM (30m, 60°N to 56°S)
   - Copernicus DEM (30m/90m, global, newest 2021)
   - ASTER GDEM (30m, 83°N to 83°S)
   - ALOS World 3D (30m free, 5m paid)

### OpenTopography Rate Limit Coordination (CRITICAL)

**All download processes MUST check shared rate limit state before downloading.**

- **Shared state file**: `data/.opentopography_rate_limit.json`
- **Automatic coordination**: All downloaders check this file before requests
- **Simple backoff**: 10 minutes initial, doubles each 401 (10min → 20min → 40min...)
- **Request spacing**: 0.5s delay between OpenTopography requests
- **Multi-process safe**: Thread-safe file locking prevents race conditions

**Implementation** (already integrated in all OpenTopography downloaders):
```python
from src.downloaders.rate_limit import check_rate_limit, record_rate_limit_hit, record_successful_request

# Before download
ok, reason = check_rate_limit()
if not ok:
    return False  # Rate limited

# After 401
if response.status_code == 401:
    record_rate_limit_hit(response.status_code)
    raise OpenTopographyRateLimitError()

# After success
record_successful_request()
```

**CLI utility**: `python check_rate_limit.py` - Check status, clear limits, wait for clearance

**Rate Limit Coordination**: All downloaders check shared rate limit state before downloading via `data/.opentopography_rate_limit.json`

### Other Data Sources
- **ERA5 Climate Reanalysis**: Comprehensive global climate data
- **WorldClim**: Bioclimatic variables at various resolutions
- **Natural Earth**: Country borders (public domain, 10m/50m/110m resolution)

### Download and Cleaning Philosophy
1. Download by bounding box or tiles (most sources provide this)
2. Clip/mask to administrative boundaries locally (automated)
3. Cache both raw (bounding box) and cleaned (clipped) versions
4. Use two-tier caching to balance flexibility and performance

### Centralized Region Configuration
- **Single source of truth**: All regions defined in `src/region_config.py`
- **Categories**: US_STATES, COUNTRIES, REGIONS (three categories only)
- **Key principle**: Having a region configured does NOT mean data exists - check manifest/files separately
- **Utility functions**: `check_region_data_available()`, `list_available_regions()`, `is_region_configured()`
- **CRITICAL RULE**: NO scripts should store local copies of region lists. All region information must come from `src/region_config.py` via imports. This was enforced across all download scripts to eliminate duplication and maintain consistency.

### Adding New Regions (Viewer and Pipeline)
- **Quick path (viewer-focused):**
  1. Add RegionConfig entry to appropriate category in `src/region_config.py`:
     - `id`: lowercase with underscores (e.g., "japan")
     - `name`: Display name (e.g., "Japan")
     - `bounds`: Tuple(west, south, east, north) in degrees
     - `description`: Optional description
     - `category`: "usa_state", "country", "area", etc.
     - `clip_boundary`: True for countries/states, False for islands/custom areas
  2. Place a GeoTIFF at `data/regions/<region_id>.tif` (or `<region_id>_elevation.tif`).
  3. Generate JSON + manifest:
     - `python ensure_region.py <region_id>` (full pipeline)
     - Outputs to `generated/regions/` and updates `regions_manifest.json`.
  4. Start the viewer: `python serve_viewer.py` and select the region.

- How the viewer groups regions:
  - Countries (international) → first group; detected from manifest names not matching island/peninsula/range patterns.
  - Regions (non-country: islands/peninsulas/ranges) → second group; names containing "island|islands|peninsula|range" are auto-classified, or add id to `knownNonCountryIds` in `js/viewer-advanced.js` if needed.
  - US states → third group; ids in the hardcoded US set or prefixed with `usa_`.

- Integrated pipeline path (unified CLI):
  - Add region to `src/region_config.py` if not already present.
  - Use: `python ensure_region.py <region_id>` to run the full `src/pipeline.py` (clip → reproject → downsample → export → manifest update).

- Validation and consistency:
  - Keep bounds realistic and tight to minimize file sizes and preserve aspect.
  - Use 10m borders when clipping to countries/states; set `clip_boundary=False` for free-form islands if no boundary source.
  - After format changes, follow cache invalidation steps under “Data Format Versioning & Cache Invalidation”.

## Common Commands
```powershell
# Setup/activate environment
.\setup.ps1

# Interactive 3D viewer (primary interface)
python serve_viewer.py  # Visit http://localhost:8001

# ONE COMMAND: Ensure a region is ready (download + process + check)
# Works for BOTH US states and international regions
python ensure_region.py ohio                    # US state: Download if needed, process if needed
python ensure_region.py iceland                 # International: Auto-downloads via OpenTopography
python ensure_region.py new_hampshire           # Multi-word: use underscores
python ensure_region.py "new hampshire"         # Multi-word: or use quotes
python ensure_region.py tennessee --force-reprocess  # Force full rebuild
python ensure_region.py california
python ensure_region.py --list-regions          # List all available regions (50 US states + 8 countries + 31 regions = 89 total)

# Reprocess existing state data
python reprocess_existing_states.py --states ohio kentucky
python reprocess_existing_states.py --force  # Full rebuild all states

# Clear all caches (use after format changes)
python clear_caches.py

# Check GeoTIFF orientation
python check_geotiff_orientation.py data/your_file.tif

# Border data management
python download_borders.py                     # Pre-download borders (110m default)
python download_borders.py --resolution 10m    # High detail borders
python download_borders.py --force             # Force re-download
python border_utils.py --list                  # List all countries
python border_utils.py --list --search "united" # Search countries
python border_utils.py --info "United States of America" # Country details
python border_utils.py --bbox "-125,25,-65,50" # Find countries in region

# Production deployment
.\deploy.ps1 -Preview  # Dry run (shows what would be uploaded)
.\deploy.ps1 -Deploy   # Deploy to server

# Version bumping (after significant changes)
python bump_version.py        # Patch increment (default: 1.335 -> 1.335.1)
python bump_version.py minor  # Minor increment (1.335 -> 1.336)
python bump_version.py major  # Major increment (1.335 -> 2.0)
```

## Production Deployment

### Architecture
The viewer is a **pure client-side web application** that runs entirely in the browser:
- No server-side code required
- Works with any static web server (nginx, apache, etc.)
- All paths are relative (no configuration needed)
- External dependencies from CDN (Three.js, jQuery)

### Production vs Development Files

**Production (deploy these):**
- `interactive_viewer_advanced.html` - Main 3D viewer
- `viewer.html` - Simple viewer  
- `js/` - Client-side JavaScript
- `css/` - Stylesheets
- `generated/` - Exported elevation data (JSON)
- `README.md` - Optional documentation

**Development only (DO NOT deploy):**
- `data/` - Raw GeoTIFF files (10+ GB, stays local) - DO NOT deploy
- `src/` - Python processing code - DO NOT deploy
- `*.py` - Python scripts (processing/export only) - DO NOT deploy
- `venv/` - Virtual environment - DO NOT deploy
- Documentation files (README, install.md, etc.) - DO NOT deploy
- Cache directories, development files - DO NOT deploy

**File Size Expectations:**
- HTML/JS/CSS: ~100 KB
- Single US state: ~500 KB - 2 MB
- All US states: ~50 MB
- Raw data (not deployed): 10+ GB

### Deployment Method

**Native Windows SCP deployment** - uses OpenSSH client built into Windows 10+:

```powershell
# Preview (dry run - shows what would be uploaded)
.\deploy.ps1 -Preview

# Deploy (actual upload)
.\deploy.ps1 -Deploy
```

**Why SCP over rsync:**
- Built into Windows 10+ (no third-party tools)
- More reliable on Windows (rsync keeps stopping)
- Native PowerShell integration
- Works with existing SSH keys
- Simpler and faster

**Configuration:**
- Server details in `deploy-config.ps1` (gitignored, not in repo)
- Template: `deploy-config.example.ps1`
- Format:
  ```powershell
  $REMOTE_HOST = "yourserver.com"
  $REMOTE_USER = "username"
  $REMOTE_PATH = "/path/to/web/directory"
  $SSH_KEY = ""  # Leave empty to use default
  ```

**CRITICAL - Production File Format:**
- **Viewer ONLY loads `.json.gz` files** (compressed format)
- **NEVER deploy raw `.json` files** - they're dev-only intermediates
- Deploy script automatically filters and skips raw `.json` files
- Example: Deploy `ohio.json.gz` (3MB), skip `ohio.json` (13MB)
- Viewer code automatically appends `.gz` to JSON URLs
- Savings: ~150 files reduced to ~75 files (only compressed versions)

**Smart deployment features:**
- **Connection testing**: Tests SSH connection and remote path before deploying
- **File comparison**: Skips unchanged files using size + MD5 checks
  - Batch checks ALL files in ONE SSH call (critical for high-latency networks)
  - Prevents 3-8 SSH calls per file (would be 5-40s per file at 95-585ms latency)
- **Upload prioritization**: Manifests/code first, then data files
  - Priority: HTML, JS, CSS, manifests go first
  - Data: Region `.json.gz` files upload last
  - Rationale: If interrupted, viewer won't break loading missing regions
- **Progress tracking**: Shows percent complete, file counts, skipped files
- **High-latency optimization**: 
  - Compression: `-C` flag (massively helps text files)
  - Fast cipher: `aes128-gcm@openssh.com` (hardware-accelerated)
  - Batch operations: Single SSH call for all remote checks
- **Raw JSON filtering**: Automatically skips `.json` files (viewer only uses `.json.gz`)

**What gets deployed** (~50-100 MB):
- HTML viewer files
- JavaScript and CSS
- Generated JSON data (`generated/regions/`)
- Only `.json.gz` files (skips raw `.json`)
- Favicons and assets

**What stays local:**
- Raw GeoTIFF data (~10+ GB in `data/`)
- Python processing code (`src/`, `*.py`)
- Documentation files
- Virtual environment (`venv/`)

**SSH Key Permissions (Windows):**
If SSH fails with "bad permissions" error on private key:
```powershell
# Fix permissions - remove inheritance and grant only current user
icacls C:\Users\USERNAME\.ssh\id_rsa /inheritance:r
icacls C:\Users\USERNAME\.ssh\id_rsa /grant:r "$env:USERNAME`:F"

# Remove any extra permission entries
icacls C:\Users\USERNAME\.ssh\id_rsa /remove "YAY\None"
icacls C:\Users\USERNAME\.ssh\id_rsa /remove "NULL SID"
```
Final result should show only: `USERNAME:(F)` (full control for user only)
- Raw `.json` files (only `.json.gz` deployed)

**Performance:**
- First deploy: ~2-3 minutes (uploads everything)
- Subsequent deploys (no changes): ~10-15 seconds (skips all)
- Typical deploy (few changed files): ~20-30 seconds

**Troubleshooting:**
- If `scp` not found: Install OpenSSH Client via Windows Settings > Apps > Optional Features
- If connection fails: Check SSH key with `ssh username@server`
- Manual upload: `scp -r js css generated *.html username@server:/path/`

### Version Bumping

After significant changes, increment the viewer version to bust browser caches:

```bash
python bump_version.py        # Patch: 1.335 -> 1.335.1 (bug fixes, minor tweaks)
python bump_version.py minor  # Minor: 1.335 -> 1.336 (new features, improvements)
python bump_version.py major  # Major: 1.335 -> 2.0 (breaking changes, major redesigns)
```

**What it does:**
1. Updates `VIEWER_VERSION` in `js/viewer-advanced.js`
2. Automatically syncs HTML cache busters
3. Ready to deploy

**When to bump:**
- User-facing changes (new features, bug fixes, UI changes)
- Before deployment of significant work
- After completing a development session
- NOT needed for internal refactoring or documentation updates

## Automation Goals
- Minimize manual steps
- Make data acquisition automatic and cached
- Enable one-command visualization generation
- Support parametric variations (regions, variables, time periods)
- One-command deployment with smart file comparison (skip unchanged files)

## Deployment Best Practices

### Pre-Deployment Checklist
1. **Process regions**: Run `ensure_region.py` for any new/updated regions
2. **Bump version**: Run `bump_version.py` to bust browser caches
3. **Preview first**: Always run `.\deploy.ps1 -Preview` to see what will upload
4. **Deploy**: Run `.\deploy.ps1 -Deploy` after reviewing preview

### Connection Requirements
- SSH key authentication (password auth not supported in script)
- OpenSSH client installed (built into Windows 10+)
- Test connection manually: `ssh username@server` should work without password

### Performance Optimization
- Script does ONE batch SSH call to check all remote files (not one per file)
- Uses file size + MD5 comparison to skip unchanged files
- Prioritizes metadata/code uploads before large data files
- Compression enabled for high-latency connections

### File Filtering Rules
- **Skip raw .json files**: Viewer only uses .json.gz (compressed)
- **Skip Python files**: Processing code stays local
- **Skip data/ directory**: Raw GeoTIFFs never uploaded
- **Include generated/**: All JSON data for viewer

## Border Features
- **Drawing borders**: Overlay country boundaries on maps
- **Masking data**: Clip elevation to country/state boundaries
- **177 countries available** (admin_0) + **US states/provinces** (admin_1) from Natural Earth
- **Resolutions**: 10m (detailed), 50m (medium), 110m (fast) - 10m recommended for production
- **Automatic download**: Borders downloaded automatically when needed during clipping
- **Pre-download option**: Use `download_borders.py` to cache borders ahead of time
- **Automatic caching**: Borders and masked data cached in `data/.cache/borders/`
- **Interactive viewer support**: Export borders for web viewer
- **Query tools**: `border_utils.py` for listing/searching countries and states
- Use `mask_country` parameter to clip data (e.g., "United States of America")
- Use hierarchical names for states: `"United States of America/Ohio"`
- Use `draw_borders` parameter in rendering to overlay border lines
- Primary workflow: Interactive 3D viewer at localhost:8001
- **Border System**: Use Natural Earth admin_0/admin_1, always use 10m resolution for production, cache borders in `data/.cache/borders/`

### Git and Large Files
- This project works with large geospatial data files (GeoTIFFs, HGT files, etc.)
- When adding new data directories or processing outputs, consider whether they might contain large files
- If so, add them to `.gitignore` immediately to prevent accidental commits
- Examples: new cache directories, intermediate processing outputs, downloaded tiles
- Keep an eye on new file types that might grow large over time

#### What Should Be Ignored
Always ignore these directories and file types to keep git lean:
- **`data/`** - Raw elevation data (GeoTIFFs, HGTs) - can be 10GB+
- **`generated/`** - Exported JSON for viewer (rebuilt from data as needed)
- **`rasters/`** - Intermediate raster processing files
- **`output/`** - Visualization outputs (PNGs, etc.)
- **Cache directories**: `data/.cache/`, `110m/` (pickled borders)
- **Binary formats**: `*.tif`, `*.tiff`, `*.hgt`, `*.img`, `*.pkl`, `*.zip`, `*.gz`
- **Python artifacts**: `__pycache__/`, `venv/`, `.pytest_cache/`
- **OS junk**: `.DS_Store`, `Thumbs.db`, `debug.log`

**Rationale**: Raw geospatial data is large (hundreds of MB to GB per file), and should be downloaded/reprocessed from source rather than stored in git. Only code, small manifests, and documentation belong in version control.

### UI Essentials
- **Region selector groups**: Countries → Areas → US States; include non-selectable dividers; alphabetical inside each group.
- **Text legibility**: Primary HUD/meta/status (project name, GitHub, FPS/version, logs) should be white on dark backgrounds.
- **Button styling standard**: ALL buttons must use white text (#ffffff) in both normal and hover states. On hover, change background color only, never text color. Use smooth transitions (0.2s).
- **HUD Overlay**: Elevation/slope/aspect data display in bottom-left corner.
  - Hidden by default; toggleable via "Show HUD Overlay" checkbox in Display section.
  - Draggable anywhere on screen; position persists in localStorage.
  - Minimize button (-) in top-right collapses HUD and unchecks checkbox.
  - Settings button at bottom opens config panel (units, visible fields).
  - Tabular layout prevents value jitter.
- **Controls**: Conceptual labels ("Resolution", "Vertical Exaggeration"), not technical jargon. Provide MAX/DEFAULT quick actions.
- **Responsiveness**: Debounce heavy updates (~50–120 ms). Apply lightweight visual changes immediately; settle once on input end.
- **Flat lighting**: Simple checkbox "Flat lighting (no shading)" under Color Scheme.
  - Default off; URL `flat=1` turns it on.
  - Uses unlit materials and ambient-only lighting when on.

### Rendering & Performance
- **GPU-first updates**: Use shader uniforms for continuous changes (exaggeration, tile gap). Rebuild geometry only when baselines change.
 - Flat lighting reduces shading cost; no shadow maps are used.

### Color Schemes
- Include `auto-stretch`: computes percentile bounds client-side; honors gamma.
- **Global Scale toggle**: Located right below "Show Scale" checkbox in Display section.
  - Purpose: Use consistent elevation range across all regions for visual comparison
  - Default: OFF (per-region auto-scaling for best contrast within each region)
  - When ON: Uses global min/max computed from all regions in manifest
  - Behavior:
    - Applies to all elevation-based color schemes (elevation, high-contrast, hypsometric, etc.)
    - Also applies to auto-stretch mode (uses global autoLow/autoHigh percentiles)
    - Does NOT apply to derived modes (slope, aspect) which use data-driven ranges
  - Updates: When toggled, immediately updates terrain colors and color legend
  - Persistence: Saved to localStorage as `useGlobalScale` preference
  - UI: Checkbox with tooltip "Use consistent elevation range across all regions for comparison"
  - Implementation:
    - Global stats computed once at manifest load (`computeGlobalElevationStats()`)
    - Exposed as `window.globalElevationStats` for modules
    - Color mapping (`map-shading.js`) checks `params.useGlobalScale` flag
    - Color legend (`color-legend.js`) shows global range when enabled
  - Use case: Compare relative elevations between regions (e.g., comparing mountain heights across states/countries)

### Removed UI
- Shading controls (sun/azimuth/altitude/contrast) and water simulation UI are not present.
- Contour lines (elevation isolines) removed completely - no UI controls, no rendering code.
- Region navigation arrows (prev/next) hidden by default.
- Render mode selector hidden by default (only bars mode supported).
