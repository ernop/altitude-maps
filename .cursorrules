# Altitude Maps - Cursor Rules

## Project Context
This is a landscape visualization project focused on showing altitude of various regions across the globe.

## Project Organization - Documentation Structure

### Root Level - Essential Files Only
- **`.cursorrules`** - AI agent guidance and development patterns
- **`README.md`** - Public user documentation (product-focused)
- **`DEPLOY_README.md`** - Production deployment guide (exception for ops)

### Technical Documentation (`tech/` folder)
All technical documentation goes in `tech/` folder with standardized naming:
- **`USER_GUIDE.md`** - Complete usage guide (consolidated from QUICKSTART, PRODUCT_REQUIREMENTS, etc.)
- **`TECHNICAL_REFERENCE.md`** - Complete API reference, file formats, technical specs (from TECH.md)
- **`DOWNLOAD_GUIDE.md`** - Data acquisition workflows (from UNIFIED_DOWNLOADER_GUIDE.md)
- **`DEPLOYMENT_GUIDE.md`** - Production deployment instructions and server configuration
- **`CAMERA_CONTROLS.md`** - Camera system documentation (consolidated from learnings/*CAMERA*.md)
- **`DATA_PRINCIPLES.md`** - Core data handling principles and validation rules

### Historical Learnings (`learnings/` folder)
Session notes and development threads only:
- **`SESSION_YYYYMMDD_description.md`** - Session-specific notes (use standardized date format)
- **`[FEATURE]_SUMMARY.md`** - Feature-specific learnings (e.g., DEPTH_BUFFER_PRECISION_CRITICAL.md)
- **`[FEATURE]_FIX.md`** - Bug fix summaries (e.g., ASPECT_RATIO_FIX_SUMMARY.md)

### Rules for Creating Documentation
1. **File format**: All documentation MUST be `.md` (Markdown) format - NEVER create `.txt` documentation files
2. **New user-facing content**: Add to `tech/USER_GUIDE.md` (don't create new files)
3. **New technical specs**: Add to `tech/TECHNICAL_REFERENCE.md` (don't create new files)
4. **New features**: Update both README.md (brief mention) and tech/USER_GUIDE.md (detailed)
5. **Session notes**: Create `learnings/SESSION_YYYYMMDD_description.md` with standardized naming
6. **Bug fixes/learnings**: Create `learnings/[FEATURE]_FIX_SUMMARY.md` or similar
7. **Deployment/ops**: DEPLOY_README.md at root is acceptable (operational necessity)
8. **Never create**: Other root-level documentation files (no `.txt`, no extra `.md` files - keep root clean)

### Why This Structure
- **Clean root**: Easy to find the main docs
- **Logical grouping**: All technical info in one place (`tech/`)
- **Historical preservation**: Session notes preserved in `learnings/`
- **Easy maintenance**: Fewer files, less duplication, single source of truth

## Development Patterns

### Environment
- Always use Python 3.13 virtual environment (`venv`)
- Activate with `.\venv\Scripts\Activate.ps1` in PowerShell
- Dependencies managed via `requirements.txt`

### Code Style
- Use type hints for function parameters and returns
- Keep functions focused and single-purpose
- Document complex data transformations with inline comments
- Use meaningful variable names (prefer `elevation_data` over `ed`)

### Frontend/Web Viewer
- **jQuery and Select2**: Keep them. jQuery is widely cached and makes code more readable. Select2 provides good UX for dropdowns.
- **CSS styling**: Avoid inline styles. Use rationally-named CSS classes instead.
- **File organization**: Separate HTML and JS into different files rather than mixing them.
- **Code reuse**: Don't duplicate code, but also don't force artificial reuse when use cases actually differ. Balance DRY with clarity.

#### UI Control Organization
- **Bidirectional controls**: Split into two clear columns with user-friendly labels (e.g., "HIGHER DETAIL" vs "LOWER DETAIL")
- **Visual hierarchy**: Use color-coded headers to distinguish control groups (green = higher detail, orange = lower detail)
- **Button layout**: Vertical stacking within columns works better than horizontal wrapping
- **Quick access buttons**: Provide MAX and DEFAULT buttons for common settings (bucket size 1 and auto-calculated optimal)
- **Labels**: Use conceptual names over technical terms (e.g., "Resolution" not "Bucket Size")

### Data Handling
- Store raw data in `data/` directory (gitignored)
- Within there, store items of different types in a distinguishable way; for example, each file type should be able to be detected.
- Cache processed data to avoid re-downloading (including masked/bordered data)
- Always validate data ranges and handle missing values
- GeoTIFF data uses natural orientation (North up, East right) - no transformations needed
- Use geopandas for geographic borders and masking operations

#### Core Data Principles - CRITICAL

⚠️ **Principle 1: Preserve Real-World Proportions**

Our goal is to accurately represent geographic data with correct proportions. A wide state like Tennessee (8.7° wide × 1.7° tall) must appear wide, not square. A tall state like New Jersey must appear tall. 

**Implementation**: When masking to administrative boundaries (states/countries), crop the output to the actual shape boundaries, not the rectangular bounding box. This removes empty space that would distort aspect ratios.

**Validation**: Export process automatically validates aspect ratio against geographic reality (see `src/validation.py`). Exports fail if proportions are >30% incorrect.

⚠️ **Principle 2: Treat Input Data as Uniform 2D Grid**

Elevation data from GeoTIFFs is a simple 2D array of height values at evenly-spaced grid points. **Do not reinterpret or transform this data** based on latitude/longitude when rendering:

- ✅ **Correct**: Render as uniform square grid (each pixel = one unit of space)
- ❌ **Wrong**: Apply latitude-dependent scaling or geographic projections in the viewer

**Why**: The input data already has correct proportions built in (from the masking/cropping process). Adding transformations in the viewer would apply corrections twice, creating distortion.

**In the viewer (Three.js)**:
```javascript
// ✅ CORRECT - Simple uniform grid
const geometry = new THREE.PlaneGeometry(width, height, width-1, height-1);

// ❌ WRONG - Don't add geographic transformations
const widthMeters = lonSpan * cos(lat) * 111_320;  // NO!
const geometry = new THREE.PlaneGeometry(widthMeters, heightMeters, ...);
```

**In data export**: Ensure cropping produces correct aspect ratios so viewer needs no corrections.

**When downsampling**: Always use the **same step size for both dimensions**:
```python
# ✅ CORRECT - Preserves aspect ratio
step_size = max(1, int(math.ceil(max_dim / target_pixels)))
downsampled = elevation[::step_size, ::step_size]

# ❌ WRONG - Distorts aspect ratio
step_y = height // target_height  # Different
step_x = width // target_width    # Different
downsampled = elevation[::step_y, ::step_x]  # Distorts!
```

### Data Format Versioning & Cache Invalidation
--- You must clearly and explicitly state what each filetype is andhow  it works. Don't leave it disogranized.
⚠️ **CRITICAL**: When changing data processing/export format:
1. **Update the format version number** in export scripts
2. **Add version validation** on data load (fail if version mismatch)
3. **Document the change** in code comments
4. **Re-export ALL cached/generated data** - don't mix old and new formats

Cached/Generated Data Locations:
- `data/.cache/` - Masked/bordered raster data (pickled)
- `generated/` - Exported JSON for web viewer
- `generated/regions/` - Per-region exported data

To invalidate all caches after format changes:
```powershell
# Delete cached data
Remove-Item -Recurse -Force data\.cache\*
Remove-Item -Recurse -Force generated\*

# Re-export from source GeoTIFFs
python export_for_web_viewer.py
python download_regions.py  # If using regions
```

### Visualization
- Save outputs to `output/` directory
- Create both static (matplotlib) and interactive (plotly) versions when appropriate
- Use clear, colorblind-friendly color schemes
- Add proper titles, labels, and legends
- Include data source citations in visualizations
- **Vertical Exaggeration**: Uses real-world scale where 1.0 = true Earth proportions, 2.0 = mountains twice as steep as reality. Both X/Z (horizontal) and Y (elevation) axes are in meters based on lat/lon bounds.

### 3D Rendering (Three.js)
⚠️ **CRITICAL - Camera Near/Far Planes**:
- **ALWAYS** maintain reasonable near/far plane ratios (< 1,000,000:1)
- Current safe values: `near=1, far=100000` (100,000:1 ratio)
- **NEVER** use extreme values like `near=0.001, far=50000000`
- Extreme ratios cause depth buffer artifacts (distant geometry bleeds through nearby geometry)
- Symptoms: Jagged artifacts that vary with camera angle, worse at oblique views
- **See `learnings/DEPTH_BUFFER_PRECISION_CRITICAL.md` before modifying camera settings**
- Runtime validation will log errors if ratio exceeds safe limits

#### Performance Tuning
- **Default bucket size**: Auto-adjust targets ~3,900 buckets (not 10,000) for better initial performance
- **User can refine**: Provide granular controls (-10/-5/-1/+1/+5/+10) for users who want more detail
- **Performance over quality**: Start conservative (larger buckets), let users increase detail if they want
- **Rationale**: Better to load fast with decent quality than slow with perfect quality - users will adjust if needed

### Camera Controls - Best Known Scheme (Oct 2025)
**Ground Plane Camera System** - Tested and confirmed buttery smooth, modeled after Google Maps/Earth.


**Core Architecture (CRITICAL for smoothness):**
- Fixed ground plane at y=0 (the map surface)
- Focus point anchored ON the plane (where camera looks)
- All operations relative to this plane
- **camera.lookAt() called ONLY in update() loop** (once per frame, synchronized with rendering)
- **NEVER call camera.lookAt() in mouse event handlers** - this causes high-frequency jitter
- Mouse handlers only update positions; render loop handles orientation

**Control Behaviors:**

1. **Left Drag = Pan on Ground Plane**
   - Behavior: "Grab and drag" the map surface
   - Drag DOWN → map moves down, Drag UP → map moves up
   - Drag LEFT → map moves left, Drag RIGHT → map moves right
   - Implementation: Screen-space movement for smoothness (not continuous raycasting)
   - Speed: Adaptive based on distance from focus point (distance * 0.001)
   - Camera and focus point move together, maintaining view angle

2. **Shift + Left Drag = Tilt View (Pitch Adjustment)**
   - Behavior: Change viewing angle to see more/less terrain
   - Drag DOWN → tilt down (increase phi angle, see more land/horizon)
   - Drag UP → tilt up (decrease phi angle, more overhead view)
   - Implementation: Spherical coordinate adjustment around focus point
   - Angle limits: 0.1 to π/2 - 0.01 radians (prevents camera flip)
   - Tilt speed: 0.005 radians per pixel
   - Cancels smoothly if Shift released mid-drag (prevents jank)
   - Focus point stays fixed on ground plane

3. **Right Drag = Rotate View (Google Earth style)**
   - Behavior: Rotate view around focus point (Google Earth style)
   - Horizontal drag → turn left/right (rotate around vertical axis)
   - Vertical drag → tilt up/down (adjust viewing angle)
   - Implementation: Spherical coordinate transformation around focus point
   - Rotation speed: 0.005 radians per pixel
   - Maintains constant distance from focus point
   - Same angle limits as tilt to prevent camera flipping
   - **Alternative mapping:** Alt + Left Drag (Maya/3ds Max/Cinema 4D style - same behavior)
   - Cancels smoothly if Alt released mid-drag (prevents jank)

4. **Mouse Wheel = Zoom Toward/Away From Cursor**
   - Behavior: Zoom toward point under cursor (Google Maps style)
   - Scroll UP (negative delta) → zoom IN = camera moves toward cursor point
   - Scroll DOWN (positive delta) → zoom OUT = camera moves away from cursor point
   - Zoom factor: 10% of distance per scroll tick
   - Minimum distance: 5 meters (prevents getting too close)
   - **Bidirectional focus shift (CRITICAL for smooth zoom):**
     - Zoom IN: Focus moves toward cursor (focusShift = +0.1)
     - Zoom OUT: Focus moves away from cursor (focusShift = -0.1)
     - This ensures camera AND focus move in same direction (no conflict)
   - Cursor point stays visually stable under mouse

5. **WASD/QE/F Keys = Keyboard Movement**
   - Behavior: First-person style camera movement (always active when not typing)
   - W = move forward in view direction
   - S = move backward
   - A = strafe left
   - D = strafe right
   - Q = move down (descend)
   - E = move up (ascend)
   - **F = Reframe view** - Reset to fixed overhead map view:
     - Position: Fixed at (0, 50000, -50) looking at origin
     - Height: 50,000 units (works well for most states)
     - Orientation: North (+Z) at top of screen (consistent every time)
     - Applied automatically after every region load
     - Perfect for getting oriented after exploring
   - Works simultaneously with all mouse controls
   - Speed: 2.0 units per frame
   - Focus point moves with camera to maintain ground plane model
   - **Disabled when typing:** WASD keys don't affect camera when typing in input fields, textareas, Select2 boxes, etc.

6. **Touch/Trackpad Gestures** (NEW - Google Maps style)
   - **Single finger drag** = Pan (mobile touch)
   - **Two-finger drag** = Pan (trackpad/desktop, Google Maps style)
   - **Two-finger pinch** = Zoom in/out (pinch together = zoom in, spread apart = zoom out)
   - **Simultaneous pan + zoom** = Two-finger gesture supports both at once
   - Implementation: Touch event handlers with gesture recognition
   - Prevents default touch behavior to avoid page scrolling
   - Zoom sensitivity: 1% per pixel of pinch distance change
   - All gestures maintain ground plane model (focus stays at y=0)
   - Works on mobile devices (phones/tablets) and desktop trackpads (MacBook, etc.)

**Implementation Pattern (DO NOT DEVIATE):**
```javascript
// In mouse event handlers (onMouseMove, onWheel):
// 1. Calculate new camera position
this.camera.position.copy(newPosition);

// 2. Update focus point if needed
this.focusPoint.copy(newFocusPoint);

// 3. Update controls target
this.controls.target.copy(this.focusPoint);

// 4. DO NOT call camera.lookAt() here!
// The update() loop handles this once per frame

// In update() loop (called by requestAnimationFrame):
update() {
    if (this.enabled && this.focusPoint) {
        this.camera.lookAt(this.focusPoint); // ONLY place this is called
    }
}
```

**Why This Works:**
- Single source of truth for camera orientation (no fighting between handlers)
- Synchronized with render loop (60fps, no micro-stutters)
- Predictable timing regardless of input frequency
- Standard pattern used by Three.js OrbitControls and professional systems

**What NOT To Do:**
- ❌ Don't call camera.lookAt() in mouse handlers (causes jitter)
- ❌ Don't use continuous raycasting for pan (too slow/jerky)
- ❌ Don't make focus shift unidirectional (breaks zoom out feel)
- ❌ Don't forget to cancel operations if modifier keys released mid-drag
- ❌ Don't process keyboard shortcuts when user is typing in input fields
- ❌ Don't break existing controls when adding new features (additive only)

### Testing
- Test with small data samples first before processing large datasets
- Verify coordinate systems and projections
- Check data units and conversions
- Validate output visualizations manually

### Documentation
- Update README.md for major feature additions
- Document significant learnings in `learnings/learnings_N_<topic>.md`
- Keep inline code comments focused on "why" not "what"
- Never describe your own work as "stunning", "beautiful", "incredible" - don't be a braggart
- Be humble about work you've done, not ostentatiously humble, just light and clear
- Explain things as needed without self-praise

**What "learnings" actually means:**
- Learnings are about project-specific constraints, patterns, and gotchas discovered through experience
- NOT just "how to fix X" - that's procedural knowledge anyone could look up
- YES: "We need to watch for large files because geospatial data grows quickly and breaks git"
- NO: "Here's the git command to remove large files from history"
- Think: What would future you need to remember about this project's unique characteristics?

## Data Sources Strategy

### Elevation Data Priority (User Preference)

**USA - Always Use USGS 3DEP First:**
- Source: USGS 3D Elevation Program (3DEP)
- Resolution: 1-10m (far better than global sources)
- Coverage: Full USA
- Workflow: Download bounding box → Clip to state boundaries → Cache both
- Auth: May require API key (user will provide if needed)
- URL: https://elevation.nationalmap.gov/

**Global - Prefer Nation-Specific Sources:**
Priority order for any country:
1. **National agency data** (if available) - Always check first
   - Examples: Australia (Geoscience), Japan (GSI), Germany (BKG), UK (Ordnance Survey)
   - Often higher resolution and quality than global datasets
   - May require country-specific download process
2. **Global fallback sources** (if national unavailable):
   - OpenTopography SRTM (30m, 60°N to 56°S)
   - Copernicus DEM (30m/90m, global, newest 2021)
   - ASTER GDEM (30m, 83°N to 83°S)
   - ALOS World 3D (30m free, 5m paid)

### Other Data Sources
- **ERA5 Climate Reanalysis**: Comprehensive global climate data
- **WorldClim**: Bioclimatic variables at various resolutions
- **Natural Earth**: Country borders (public domain, 10m/50m/110m resolution)

### Download and Cleaning Philosophy
1. Download by bounding box or tiles (most sources provide this)
2. Clip/mask to administrative boundaries locally (automated)
3. Cache both raw (bounding box) and cleaned (clipped) versions
4. Use two-tier caching to balance flexibility and performance

## Common Commands
```powershell
# Setup/activate environment
.\setup.ps1

# Interactive 3D viewer (primary interface)
python serve_viewer.py  # Visit http://localhost:8001

# ONE COMMAND: Ensure a region is ready (download + process + check)
python ensure_region.py ohio                    # Download if needed, process if needed
python ensure_region.py new_hampshire           # Multi-word: use underscores
python ensure_region.py "new hampshire"         # Multi-word: or use quotes
python ensure_region.py tennessee --force-reprocess  # Force full rebuild
python ensure_region.py california --target-pixels 4096  # High resolution

# Check region data through entire pipeline
python check_region.py ohio                     # Check all stages (raw → JSON)
python check_region.py north_dakota --verbose   # Multi-word state (detailed output)
python check_region.py tennessee --raw-only     # Only check raw file

# Reprocess existing state data
python reprocess_existing_states.py --target-pixels 2048 --states ohio kentucky
python reprocess_existing_states.py --target-pixels 2048 --force  # Full rebuild all states

# Export data for web viewer
python export_for_web_viewer.py data/usa.tif

# Clear all caches (use after format changes)
python clear_caches.py

# Check GeoTIFF orientation
python check_geotiff_orientation.py data/your_file.tif

# Run visualization (static output)
python visualize.py --region global --variable temperature

# Download regions
python download_regions.py

# Work with borders
python border_utils.py --list  # List available countries
python border_utils.py --test your_data.tif  # Test borders on data

# Production deployment
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy -DryRun  # test
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy          # deploy
```

## Production Deployment

### Architecture
The viewer is a **pure client-side web application** that runs entirely in the browser:
- ✅ No server-side code required
- ✅ Works with any static web server (nginx, apache, etc.)
- ✅ All paths are relative (no configuration needed)
- ✅ External dependencies from CDN (Three.js, jQuery, Select2)

### Production vs Development Files

**Production (deploy these):**
- `interactive_viewer_advanced.html` - Main 3D viewer
- `viewer.html` - Simple viewer  
- `js/` - Client-side JavaScript
- `css/` - Stylesheets
- `generated/` - Exported elevation data (JSON)
- `README.md` - Optional documentation

**Development only (DO NOT deploy):**
- ❌ `data/` - Raw GeoTIFF files (10+ GB, stays local)
- ❌ `src/` - Python processing code
- ❌ `*.py` - Python scripts (processing/export only)
- ❌ `venv/` - Virtual environment
- ❌ `tech/`, `learnings/` - Documentation
- ❌ Cache directories, development files

**File Size Expectations:**
- HTML/JS/CSS: ~100 KB
- Single US state: ~500 KB - 2 MB
- All US states: ~50 MB
- Raw data (not deployed): 10+ GB

### Deployment Scripts

```powershell
# PowerShell (Windows)
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy -DryRun
.\deploy.ps1 -RemoteHost example.com -RemotePath /var/www/maps -RemoteUser deploy

# Bash (Linux/Mac)
./deploy.sh -h example.com -p /var/www/maps -u deploy -d  # dry run
./deploy.sh -h example.com -p /var/www/maps -u deploy      # deploy
```

Scripts use `rsync` to:
- Upload only viewer files (excludes raw data)
- Preserve directory structure
- Sync changes efficiently (only modified files after first deploy)
- Show progress

See `DEPLOY_README.md` for detailed deployment documentation.

## Automation Goals
- Minimize manual steps
- Make data acquisition automatic and cached
- Enable one-command visualization generation
- Support parametric variations (regions, variables, time periods)

## Border Features
- **Drawing borders**: Overlay country boundaries on maps
- **Masking data**: Clip elevation to country boundaries
- **177 countries available** from Natural Earth (10m/50m/110m resolution)
- **Automatic caching** of borders and masked data
- **Interactive viewer support**: Export borders for web viewer
- Use `mask_country` parameter to clip data (e.g., "United States of America")
- Use `draw_borders` parameter in rendering to overlay border lines
- Primary workflow: Interactive 3D viewer at localhost:8001

### Git and Large Files
- This project works with large geospatial data files (GeoTIFFs, HGT files, etc.)
- When adding new data directories or processing outputs, consider whether they might contain large files
- If so, add them to `.gitignore` immediately to prevent accidental commits
- Examples: new cache directories, intermediate processing outputs, downloaded tiles
- Keep an eye on new file types that might grow large over time

